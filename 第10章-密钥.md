# 密钥
作为一个安全设备，TPM最强大的功能就是，应用程序在使用密钥的同时保证密钥安全地保存在硬件设备中。TPM可以生成密钥，也可以导入在外部生成的密钥。它支持对称和非对称密钥。第二章已经描述了这两种密钥的基本原理。

因为TPM设备的存储资源有限，必要时应用程序可以安全地将密钥换入换出TPM，这时TPM可以被认为是一个密钥缓存。相关操作会在“密钥缓存”这一节描述。

一共有三种密钥组织架构，它们分别受控于不同的安全角色。每一种组织架构都可以将密钥组织成树形父子关系。第九章已经描述了组织架构和它们的应用。

每一个密钥都有独立的安全控制方式，包括口令，增强的授权策略，密钥复制到其他父节点或者其他TPM的限制，签名或者加解密密钥的用途限制。密钥可以被认证也可以用于认证其他密钥。密钥属性相关的内容将会在“密钥类型和属性”这一节中讨论。适用于所有TPM实体的授权操作细节，包括口令和policy，将会被推迟到第13，14章介绍。

## 密钥命令
下面介绍经常用于密钥操作的TPM命令。需要说明的是，下面的列表并不是完整的命令。参考TPM2.0规范第3部分来了解完整的命令集和API细节。这些命令将按照后续章节中描述和应用案例中出现的顺序来介绍：

* TPM2_Create和TPM2_CreatePrimary可以通过模板创建所有类型的密钥。
* TPM2_Load(用于加密的私钥)和TPM2_LoadExternal(用于公钥或者明文私钥)可以将密钥加载到TPM中。
* TPM2_ContextSave和TPM2_ContextLoad用于将密钥换入换出TPM缓存。TPM2_FlushContext用于删除TPM中的密钥。TPM2_EvictControl可以让一个密钥持续存在与TPM中或者删除一个持续存在的密钥。这些函数及其应用将会在18章详细介绍。
* TPM2_Unseal，TPM2_RSA_Encrypt，和TPM2_RSA_Decrypt使用加密密钥完成相关操作。
* TPM2_HMAC，TPM2_HMAC_Start，TPM2_SequenceUpdate，和TPM2_SequenceCompete使用对称签名密钥和HMAC算法完成相关操作。
* TPM2_Sign是一个通用的签名命令，TPM2_VerifySignature用于验证数字签名。
* TPM2_Certify，TPM2_Quote，TPM2_GetSessionAuditDigest，TPM_GetTime是用于对认证数据签名的特殊命令。具体来讲，TPM2_Certify可以实现一个密钥签名另外一个密钥（密钥的名称）。这样以来，TPM就可以作为一个证书授权机构，使用自己的密钥认证证书相关密钥的属性。

## 密钥生成器
理论上来说，TPM最强大的能力是，它能产生密钥并将相关的秘密信息安全地保存在硬件中。密钥生成器基于TPM自己的随机数发生器，它不依赖任何外部的随机源。因此，它消除了由较弱的软件随机数生成器或者不充足的熵值带来的弱点。

## 主密钥和种子
TPM的密钥可以组成一个等级架构，在这个架构中父节点的密钥用于加密子节点的密钥。主密钥就是这个密钥组织架构中的根密钥。它们没有父节点。第9章讨论了组织架构的通用概念及其应用。后续再“密钥组织架构”这一节我们将重点讨论一些密钥相关的组织架构。

这一小结将按照主密钥生成和销毁的顺序讨论。在本节叙述中，调用者表示对TPM做初始配置，发送命令和接收命令响应的软件；TPM则是执行命令的硬件设备。配置软件（参考第19章）通常会执行上述步骤。用户可能会使用主密钥，但是通常他们不会创建这些主密钥。

主密钥的创建命令使用易于理解的命名方式TPM2_CreatePrimary。如果你熟悉TP1.2，你就知道TPM1.2中有一个和TPM2.0主密钥相同的密钥：根存储密钥（SRK），这个密钥会一直存在于TPM中。TPM2.0允许有无限多个主密钥，但是它们并不一定一直存在于TPM中。你可能会说，因为TPM的永久性存储空间有限，所以密钥的数量也不可能是无限多的，事实不是这样的。主种子的存在可以支持无限多主密钥。

TPM1.2在只有一个密钥的情况仍然可以工作的原因有两个。首先，它只有一个密钥算法和一个密钥大小用于加密密钥，那就是RSA-2048。然而TPM2.0中支持多种密钥算法和多种密钥大小。其次，TPM1.2只有一个密钥组织架构：存储组织架构。TPM2.0有三种组织架构，每一种都至少有一个根节点。第9章已经介绍过组织架构的一般概念和它们的应用案例。

那么，究竟TPM是怎么用有限的非易失性存储空间来实现不限数量的根密钥的呢？要知道的是，一个根密钥不能存储在TPM之外的，因为它没有父密钥来加密它的私有部分。答案就是主密钥种子。

三个组织架构的每一个都和一个主密钥种子关联，分别是：背书主密钥种子，平台主密钥种子，和存储主密钥种子。这些种子一直存在于TPM设备中。它们就是密钥生成函数输入的秘密信息。当TPM创建一个主密钥时，它使用主密钥种子和一个公共模板来生成密钥。密钥模板包含了所有的密钥配置信息：密码算法和密钥长度，密钥的policy，密钥的类型（签名，加密等等）。调用者还可以在模板中添加自己的独有数据。都有数据在模板的公钥区域中添加。

密钥生成函数时固定且可重复的。对于相同的种子来说，相同的密钥模板总是会产生相同的密钥。通过改变独有数据，调用者可以创建无限多个主密钥。

当TPM创建好一个主密钥后，密钥就存储在TPM的易失性内存中。这时候用户有两种选择。通过TPM2_EvictControl将有限数量的主密钥转到非易失性的内存空间。剩下的主密钥继续保存在易失性内存中。

如果所需的主密钥数量多于TPM可以保存到持续性存储空间和易失性存储空间中的密钥数量，可以选择性地将密钥从易失性内存中清除，或者先将非易失性存储空间中的密钥移动到易失性存储空间，然后再清除。因为密钥种子时永久性的，所以密钥永远不会丢失。因为如果调用者知道可能是完全公开的密钥模板，TPM就可以在需要的时候重新创建一个完全一样的密钥。进一步讲，如果重新创建的密钥是RSA密钥，那这个过程可能需要很长时间。如果重新创建的密钥是椭圆曲线，AES，或者HMAC密钥，创建的过程就会非常快。在大多数的应用场景中，在存储组织架构下至少有一个主存储密钥是持续性存在的，它的角色和SRK类似。

在实际应用中上述的功能具体是怎样工作的呢？在TPM1.2中，有一个背书密钥和与这个密钥相关的TPM厂商签名过的证书。他们被存储在非易失性内存中，这样以来最终的用户使用包含TPM设备的系统时，它们也就同样拥有了这个背书密钥的证书，证书和密钥通常被存储在TPM的NVRAM中。在TPM2.0中，用户可以拥有多个密钥/证书对儿，TPM实现的每一中算法至少一对。但是，用户可能不想使用珍贵的持续性存储空间用户存储密钥和证书，尽管TPM可以这样做。

既然不想浪费持续性存储空间，那应该怎么办呢？一个可能的，同时也是TPM厂商期望的解决方法是，让TPM生产商使用背书密钥种子生成几个背书主密钥钥和相应的证书，密钥使用标准算法集和广为人知的模板。其中的一种密钥及其证书，比如流行的RSA-2048被存储到持续性内存中。厂商将剩下的密钥清除，但是保存相应的证书。

TCG的基础设施工作组已经定义了一些背书主密钥的模板。RSA模板使用RSA-2048，SHA-256，和AES-128。ECC模板使用NIST-P256曲线，SHA-256，和AES-128。这两种模板使用相同的授权策略，这个授权策略要求知道背书组织架构的口令。这个策略代理了背书组织架构管理员的密钥授权。模板的独有数据部分是空的。密钥属性是（参看“密钥类型和属性”小节）fixedTPM和fixedParent都为真，也就是背书密钥被期望的那样，不能被复制。userWithAuth和adminWithPolicy被指定到Policy中，这样以来密钥必须使用policy授权，而不是口令。这样也是合理的，因为TPM厂商没有办法向用户传递口令。密钥的类型是restricted decryptkey：也就是说，是一个存储密钥。

基于前面的描述，假设用户想要一个不同的主密钥。他可以将TPM厂商预置在TPM中的密钥清除，然后自己选择算法重新生成一个主密钥。

这时候神奇的事情发生了！因为密钥的种子没有变化，并且用户重新生成密钥的时候使用的模板与TPM厂商使用的相同，所以用户得到的密钥和TPM厂商之前生成的密钥相同。用户可以把密钥的公钥部分当作TPM厂商证书列表的索引。这个证书可以存储在一个公共的服务器上。这样用户就可以方便的访问证书并开始使用。这种可重复的密钥生成方式允许TPM厂商在生产TPM时就预先生成许多密钥及其证书，但是不用将所有的密钥都存储到非易失性内存中。最终的用户需要的时候可以重新生成。

需要注意的是，TPM厂商必须实现生成所有可能需要的主密钥和厂商办法的主密钥证书。种子是一种秘密信息，因为如果不是的话，厂商就不能确定一个公钥来自于厂商自己生产的TPM设备。

一旦种子被修改，主密钥就永远不能再重新生成了，TPM中所有基于这个种子的密钥都被认为是以清除的无效的。种子被修改也意味着所有厂商生成的证书也都将没有意义。因为TPM厂商为一个新的TPM背书密钥生成证书非常困难（因为这个过程通常是厂商在量产阶段批量生成的，线下可能需要特殊复杂的流程），所以修改背书组织架构的种子受控于平台组织架构，这里的平台组织架构通常是指OEM厂商。这也就意味着最终的用户很难修改这个种子。但是从另一方面讲，只要用户在密钥模板中的随便输入一些独有数据，他就可以创建和TPM厂商完全没有关系的，自己独立的背书密钥。这未尝不是一件好事。

```
应用案例：多个主密钥
用户可以拥有多个主存储密钥作为密钥组织架构的根节点。但是这些密钥不能全部存储在非易失性内存中。如果用户使用大家熟知的模板创建密钥，他可以在需要的时候重新创建这些密钥。

以上相关的TPM密令如下：
* TPM2_NV_Read：从TPM的NV区域中读取熟知的密钥模板。TPM厂商可能会事先配置几种模板（比如说，一个RSA和一个ECC），这些模板和厂商配置的证书相匹配。用户也有可能有公司级别的模板。
* TPM2_CreatePrimary：需要选择模板。
* TPM2_EvictControl：可以选择性地将密钥配置成持续存在于TPM中。尤其是对于RSA密钥来说，这样就能节省重新生成密钥的时间（前面提到了，重新生成这种密钥很费时间）。当然密钥也可以留在易失性内存种，每次上电以后重新生成它们。
```

## 密钥的持续性
用户可以通过TPM2_EvictControl命令将一个密钥有易失性内存转移到非易失性内存中，这样以来密钥就在两个上电周期之间保持加载状态。但是密钥的使用不需要将它变成非易失性的。通常情况下，我们只希望有一小部分主密钥，可能是一个组织架构一个，被转成持续性的，这样就可以省去重新生成密钥的时间，从而提升性能。

需要说明的是，背书，存储，和平台组织架构下除主密钥意外的其他密钥也可以被设置成持续性的。一个典型的应用案例是，在系统启动初期时硬盘不可用，但是这时候需要一个密钥。另外一个应用场景就是在资源受限的平台上，比如说嵌入式控制器，它可能没有外部的持续性非易失性的存储空间。

NULL组织架构下的密钥都不能被设置成持续性的。它们在重启后被清除。

虽然只有有限数量的密钥可以被设置成持续性的，但是TPM可以处理理论上无限多的密钥。因为应用程序将TPM当作密钥缓存来使用。

## 密钥缓存
对于不是主密钥的其他密钥来说，TPM就像是一个密钥缓存。具体来说，TPM2_Create命令创建一个密钥后，使用这个密钥的父密钥加密，然后向调用者返回加密过的密钥。用户会将密钥存储在TPM之外，可能是硬盘中。当用户需要使用这个密钥时，他必须使用TPM2_load密令将密钥加载到它的父密钥下。使用完成以后，用户可以使用TPM2_FlushContext命令将密钥从TPM内存中清除。这个使用过程与主密钥不同，主密钥没有父节点，他被创建以后会暂时保留在TPM中。

一个典型的硬件TPM可能会有5-10个密钥位置（槽，key slots）：密钥槽就是密钥可以加载到的TPM内存空间。TPM管理中间件负责将密钥换入换出密钥缓存。

如果你阅读第13章，你可能会发现密钥的handle没有包含在TPM授权参数中。相反授权使用的是名称。原因就是密钥缓存和密钥换入换入操作。一个平台可能有大量的应用软件相关的密钥存储在磁盘上，它们可能通过用户的handle来识别。但是这样以来handle的数量就会远远比TPM密钥槽的数量要多。当管理中间件重新加载一个密钥后，它可能会得到一个不同的handle，这个handle可能是和TPM密钥槽的空闲状态相关的，而不是用户初始的handle。因此，中间件必须替换用户handle。如果授权数据中包含了handle信息，那中间件替换handle将会导致授权失败。

你还可能会问，如果handle可以被替换，那如果我有两个密钥的授权秘密信息相同，我怎么知道中间件没有非法使用跟我想要用的密钥不同的密钥呢？这确实是TP1.2的一个潜在问题。

TPM2.0通过将名称添加到授权数据中来解决这个问题，名称就是密钥公钥部分的摘要值。这样以来中间件可以修改密钥的handle，但是不同改变密钥的名称。

根密钥和密钥缓存共同组成一个密钥树。TPM提供了四种这样的树，每一种都有不同的控制角色。这些树也叫做组织架构（等级结构）。

## 密钥授权
尽管TPM对密钥做硬件保护已相对软件生成密钥来说已经是很大的提高了，它仍然在此基础上提供很强的密钥访问控制功能。一个软件生成的密钥经常通过使用口令做访问控制来保护密钥。比如说，一个密钥可能会用口令来加密。这种保护的强度与口令本身的强度一样，所以这个密钥很容遭受线下的暴力攻击。也就是说，一旦攻击者拿到了加密过的密钥，解密这个密钥就变成了破解用于加密它的口令。密钥的所有者不能阻止一个高频率尝试口令的攻击方法。并且这种攻击可以被并行化，也就是说不同的机器同时使用不同的口令来实施破解。云服务已经让这种攻击变得非常容易了。

TPM针对软件生成的密钥做了两方面的改进。首先，当密钥离开TPM时，它会被一个强度很高的父密钥加密。这个时候攻击者需要破解一个强度很高的密钥而不是一个口令。其次，当密钥被加载到TPM中时，它还会收到字典攻击防护逻辑的保护。每一次攻击者尝试授权密钥失败时，这个逻辑就会记录下来。当失败的次数达到一定预置值时，TPM就会阻止密钥授权，并保持一段事先配置好的时间。这将很可能大大降低攻击者实施攻击的频率。这种频率限制机制可以保证即使破解一个很弱的口令也要耗费比破解软件密钥长得多的时间，因为软件的密钥没有尝试频率限制。第13章会详细介绍HMAC和口令授权。

TPM提供了许多比简单口令更丰富的访问控制机制。但是，最终还是基于硬件的字典攻击防护机制使得一个TPM密钥口令免于遭受攻击。

## 密钥销毁
有些时候密钥需要被销毁。因为有可能密钥的授权信息已经被泄漏了。也有可能密钥所在的机器已经另作他用了。存储在软件中的密钥几乎不能被销毁，因为这些软件可能已经被到处拷贝了。但是TPM的密钥有父密钥或者是密钥，所以它们可以被销毁。

就像第9章中描述的那样，TPM有三种持续性的组织架构（背书，存储，平台）和一个易失性的组织架构（空组织架构）。每一个架构都有它独有的主密钥种子。把主密钥种子擦出就可以阻止在相应的阻止架构下重新创建主密钥，当然这是一个影响重大并且很少做的操作。擦除主密钥就可以阻止所有它的子密钥被加载到TPM中。任何属性配置为必须存在于TPM中的密钥也都被认为是销毁了。

## 密钥组织架构
一个组织架构可以被想象成由一个父节点密钥和子密钥，或者说是祖先和后代组成。所有的父密钥都是存储密钥，也就是说这些密钥都是用于加密它们的子密钥的。因此这些存储密钥用于保护它们的子密钥，当子密钥被存储到TPM安全的硬件边界之外时，父密钥能够提供保密性和完整性。这些存储密钥的用处也因此被限制这一种。他们不能用于通用的解密操作，因为这样会泄漏子密钥的私密信息。

在组织架构最顶端的终极父密钥就是主密钥。子密钥可以是存储密钥，这种情况下它可以有自己的子密钥。子密钥也可以是非存储密钥，这种情况下它们是叶子密钥：只能是一个子密钥，而不能有自己的子密钥。

## 密钥类型及其属性
每一个密钥在创建时都会设置自己的属性。密钥属性包括以下部分：
* 用途，比如签名或者加密。
* 类型，对称或者非对称，以及相关的算法。
* 秘钥复制相关的限制。
* 用途相关的限制。

### 对称和非对称密钥属性
与TPM1.2仅支持RSA不同的是，TPM2.0支持多种非对称加密算法。TPM2.0还引出了一些完全不同的秘钥类型。

一个对称签名秘钥可以被用于TPM的HMAC命令。TPM2.0可以使用一个在TPM外从不以明文存在的秘钥做对称算法签名（又叫做MAC，Message Authentication Code）。

TPM软件规范中包含可以作为通用加解密秘钥的对称秘钥，比如AES。但是，因为一些潜在的出口限制等因素，TPM厂商可能不会包含这些功能。正因为如此，这些相关的命令在PC客户端平台规范中是可选的。从过去的经验来看，TPM厂商并没有实现这些可选的特性。

### 密钥复制属性
秘钥复制是指将一个秘钥从一个组织架构下拷贝到另外一个地方（组织架构）。这个秘钥可以成为另外一个父秘钥的子秘钥。目的组织架构或者父秘钥可以在相同或者不同的TPM中。主秘钥不能被复制；它们对于一个TPM的一个组织架构来说是固定的。

秘钥复制的初始作用是秘钥备份。如果一个秘钥被永久地锁定到一个TPM中，但是这个TPM或者TPM所在的主板损坏了，这个秘钥也就永远的丢失了。第二种应用案例就是在多个设备之间共享秘钥。举例来说，一个用户的签名秘钥可以在他的笔记本，平板和手机之前复制。

TPM1.2有一个和秘钥复制类似的过程叫做秘钥迁移。从字面意义上看，迁移的言外之意就是一个秘钥经过迁移之后只存在于目的为止，而原来的位置已经没有这个秘钥了。但是实际上并不是这样的。秘钥迁移完成之后，秘钥仍然存在于原来的位置。基于这个原因，TPM2.0将这个名字修改成了更加准确的复制。

TPM2.0的秘钥有两个控制复制的属性。在极端情况下，一个秘钥可以被锁定到一个TPM的一个父秘钥下，永远不能被复制。相反的极端情况是，一个秘钥可以随意地被复制到相同或者不同TPM的另外一个父秘钥下。

一个在上述两种极端情况中间的应用场景是，一个秘钥可以在其父秘钥被复制时也被默认地复制。这种场景可以实现对一个秘钥树的一阵个秘钥分支进行复制。这样以来，一旦一个父秘钥被复制，它所有的子秘钥也会被复制到目的位置。

TPM规范有讨论复制根和复制组的概念。复制根是指一个可以被复制的秘钥。复制的过程是显式地作用在这个秘钥上的。复制组代表这个根秘钥的所有子秘钥。当根秘钥被复制时，它的复制组也被隐式地复制。虽然子秘钥没有被显式地复制，但是因为它们的父秘钥被复制，所以它们也都跟着被复制。

控制秘钥复制属性的定义如下：
* fixedTPM：如果秘钥的这个属性被设置，这个秘钥就不能被复制了。虽然从字面意义上理解，秘钥应可以被复制到同一个TPM的不同秘钥组织架构下，但是事实上却不是这样的。
* fixedParent：如果秘钥的这个属性被设置，这个秘钥就不能被复制到不同的父秘钥下。这相当于秘钥被锁定到一个父秘钥下。

这两个布尔属性一共有如下四种组合：
* 最简单的一种是fixedTPM为真，fixedParent为假，因为TPM不允许这个配置组合存在。因为fixedTPM已经表明秘钥不能以任何形式被复制，这样fixedParent为false又暗示秘钥可以复制到不同的父秘钥下，这就自相矛盾了。
* fixedTPM和fixedParent都为真，表示这个秘钥不能以显式或隐式的方式被复制。
* fixedTPM为假，fixedParent为真，表示一个秘钥不能显式地被复制。因为它被锁定到一个父秘钥下。但是如果它的父秘钥被复制了，这个秘钥会被隐式地被复制。也就是说这个秘钥可以是复制组的一个，但是不能是复制根。
* fixedTPM和fixedParent都为假，表示一个秘钥可以以复制组或者复制根的方式被复制。如果它是一个父秘钥，那它的子秘钥也将跟它一起被复制。

上述的第四种情况或许是最有意思的，因这个秘钥可以是一个复制根。比如说，它允许复制一组秘钥，在规范中叫做复制组。意思是说，一旦父秘钥被复制了，父秘钥所有的子秘钥也立即被复制到新的位置，不同显式地对每个子秘钥进行复制操作。这也简化了跟踪一个秘钥位置的工作量。你只需要跟踪子秘钥的fixedParent为真的父秘钥就可以。

我们还需要知道的是，这些子秘钥仍然被它原有的父秘钥加密。被显式复制的秘钥必须设置fixedParent为假。经过复制之后，子秘钥可以加载到它们的父秘钥可以加载到的TPM设备中，也不用关心父秘钥由什么位置加载进TPM的。fixedParent决定的是一个秘钥是否可以被直接复制，而不是当它的父秘钥被复制时它能不能被隐式的复制（因为这是一定会发生的）。换句话说，子秘钥不会因为任何其他的TPM操作而被复制。一旦一个秘钥的父秘钥被复制，这个秘钥可以很容易地被复制并加载到新的位置。

一个子秘钥可以有多于一个父秘钥。秘钥复制的过程会建立一个新的父子秘钥关系，但是不会破坏旧的关系。秘钥被复制后它就同时是新旧父秘钥的子秘钥了。一个秘钥也可以存在于多个复制组里，只要这个秘钥有多个父秘钥的fixedParent为假。也就是说一个秘钥可以有多个是复制根的父秘钥。任何一个父秘钥被复制，这个子秘钥都将会被隐式地复制。

TPM给秘钥的父子关系增加了一个限制。只有满足下面两个条件时，一个配置为fixedTPM为真的子秘钥才可以被创建：
1. 子秘钥的父秘钥同样是fixedTPM为真（父秘钥不能被显式复制）
2. 子秘钥的父秘钥的fixedParent为真（父秘钥不能被隐式地复制）

TPM强制主密钥是这样的属性，这就保证了它固定在一个TPM中的属性。

### 受限制的签名密钥
一个签名密钥的“签名”属性的变种是“限制”属性。受限制的密钥主要用于对TPM的认证数据结构签名。这些结构包括平台配置寄存器（PCR）引用，一个正在被认证的TPM对象，一个针对TPM时间的签名，或者是针对一个审计摘要的签名。我们都知道，签名再操作上当然是针对一个摘要，但是签名验证者想要确保这个摘要不是由外部的伪造数据计算而来，然后发送给TPM来签名。比如说，一个“引用”就是一个针对一组PCR值得签名，但是真正的签名过程实际上是针对这组PCR值的摘要来做的。一个用户可能对任意PCR做摘要，然后使用一个非限制性的密钥来签名这个摘要。之后这个用户还可以声称这个签名值就是一个“引用”。但是，一个可信赖第三方会发现这个密钥不是限制性密钥，所以不会相信这个声明。因此，一个限制性的密钥可以保证这是针对一个由TPM自己产生的摘要的签名。

重申一下，一个限制性的签名密钥只能对TPM自己产生的摘要签名。这个限制性签名密钥也就是TPM1.2中的信息密钥和身份认证密钥，它们都只能对TPM内部生成的数据做签名。对于TPM内部数据而言，这个属性是很容易保证的，因为TPM是在签名操作的时候才会针对内部数据生成摘要。

但是，对于外部数据而言，只要TPM通过TPM2_SequenceComplete或者TPM2_Hash对由外部提供给TPM的数据做哈希，一个限制性密钥也可以做签名，因为TPM限制的是摘要的生成者而非生成摘要的数据来源。但是这里还有一个问题，因为上述的哈希和后面的签名操作是两个独立的命令，也就是说签名操作时需要调用者传递摘要给TPM，那TPM怎么保证调用者传递给它的摘要是在TPM内部生成的呢？

问题的答案就是凭据。当TPM计算摘要的时候，它同时还会产生一个可以证明这个摘要是TPM自己生成的凭据。并且当用户给TPM2_Sign命令传递摘要参数的同时，也必须有对应的凭据作为参数之一。如果没有的话，限制性密钥不会做签名操作的。

但是这样又怎样呢？即使这样也不能限制你要签名的数据啊（这个疑问应该是针对某些必须确保是对TPM内部的数据并且由TPM自己做哈希的应用场景，这与签名的外部数据并不冲突）？你可以对任意外部数据做上述的哈希操作并得到一个凭据。为什么TPM还要关心摘要数据的来源呢？（就是说这个本身看起来没有区分内外数据来源的能力）

这个问题的答案就是一个神奇的4字节值，叫做TPM_GENERATED。每一个认证数据结构——数据结构由TPM内部数据组成——都由这个值开始。对应的情况是，如果TPM是明确地在对外部数据做哈希，只有外部数据不是以这个神奇数据开始时才会产生凭据。

这样以来，一个连锁的结果就是，你可以使用一个限制性签名密钥对任意的外部数据做签名。但是唯有不能签名以TPM_GENERATED开始的数据。这一点就防止你篡改TPM的的认证数据，这些数据都是以这个值开始的。

### 受限制的解密密钥
## 上下文管理和加载
## 空组织架构
## 认证
## 密钥结构详解
## 总结
