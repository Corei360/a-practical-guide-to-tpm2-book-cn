# 密钥
作为一个安全设备，TPM最强大的功能就是，应用程序在使用密钥的同时保证密钥安全地保存在硬件设备中。TPM可以生成密钥，也可以导入在外部生成的密钥。它支持对称和非对称密钥。第二章已经描述了这两种密钥的基本原理。

因为TPM设备的存储资源有限，必要时应用程序可以安全地将密钥换入换出TPM，这时TPM可以被认为是一个密钥缓存。相关操作会在“密钥缓存”这一节描述。

一共有三种密钥组织架构，它们分别受控于不同的安全角色。每一种组织架构都可以将密钥组织成树形父子关系。第九章已经描述了组织架构和它们的应用。

每一个密钥都有独立的安全控制方式，包括口令，增强的授权策略，密钥复制到其他父节点或者其他TPM的限制，签名或者加解密密钥的用途限制。密钥可以被认证也可以用于认证其他密钥。密钥属性相关的内容将会在“密钥类型和属性”这一节中讨论。适用于所有TPM实体的授权操作细节，包括口令和policy，将会被推迟到第13，14章介绍。

## 密钥命令
下面介绍经常用于密钥操作的TPM命令。需要说明的是，下面的列表并不是完整的命令。参考TPM2.0规范第3部分来了解完整的命令集和API细节。这些命令将按照后续章节中描述和应用案例中出现的顺序来介绍：

* TPM2_Create和TPM2_CreatePrimary可以通过模板创建所有类型的密钥。
* TPM2_Load(用于加密的私钥)和TPM2_LoadExternal(用于公钥或者明文私钥)可以将密钥加载到TPM中。
* TPM2_ContextSave和TPM2_ContextLoad用于将密钥换入换出TPM缓存。TPM2_FlushContext用于删除TPM中的密钥。TPM2_EvictControl可以让一个密钥持续存在与TPM中或者删除一个持续存在的密钥。这些函数及其应用将会在18章详细介绍。
* TPM2_Unseal，TPM2_RSA_Encrypt，和TPM2_RSA_Decrypt使用加密密钥完成相关操作。
* TPM2_HMAC，TPM2_HMAC_Start，TPM2_SequenceUpdate，和TPM2_SequenceCompete使用对称签名密钥和HMAC算法完成相关操作。
* TPM2_Sign是一个通用的签名命令，TPM2_VerifySignature用于验证数字签名。
* TPM2_Certify，TPM2_Quote，TPM2_GetSessionAuditDigest，TPM_GetTime是用于对认证数据签名的特殊命令。具体来讲，TPM2_Certify可以实现一个密钥签名另外一个密钥（密钥的名称）。这样以来，TPM就可以作为一个证书授权机构，使用自己的密钥认证证书相关密钥的属性。

## 密钥生成器
理论上来说，TPM最强大的能力是，它能产生密钥并将相关的秘密信息安全地保存在硬件中。密钥生成器基于TPM自己的随机数发生器，它不依赖任何外部的随机源。因此，它消除了由较弱的软件随机数生成器或者不充足的熵值带来的弱点。

## 主密钥和种子
TPM的密钥可以组成一个等级架构，在这个架构中父节点的密钥用于加密子节点的密钥。主密钥就是这个密钥组织架构中的根密钥。它们没有父节点。第9章讨论了组织架构的通用概念及其应用。后续再“密钥组织架构”这一节我们将重点讨论一些密钥相关的组织架构。

这一小结将按照主密钥生成和销毁的顺序讨论。在本节叙述中，调用者表示对TPM做初始配置，发送命令和接收命令响应的软件；TPM则是执行命令的硬件设备。配置软件（参考第19章）通常会执行上述步骤。用户可能会使用主密钥，但是通常他们不会创建这些主密钥。

主密钥的创建命令使用易于理解的命名方式TPM2_CreatePrimary。如果你熟悉TP1.2，你就知道TPM1.2中有一个和TPM2.0主密钥相同的密钥：根存储密钥（SRK），这个密钥会一直存在于TPM中。TPM2.0允许有无限多个主密钥，但是它们并不一定一直存在于TPM中。你可能会说，因为TPM的永久性存储空间有限，所以密钥的数量也不可能是无限多的，事实不是这样的。主种子的存在可以支持无限多主密钥。

TPM1.2在只有一个密钥的情况仍然可以工作的原因有两个。首先，它只有一个密钥算法和一个密钥大小用于加密密钥，那就是RSA-2048。然而TPM2.0中支持多种密钥算法和多种密钥大小。其次，TPM1.2只有一个密钥组织架构：存储组织架构。TPM2.0有三种组织架构，每一种都至少有一个根节点。第9章已经介绍过组织架构的一般概念和它们的应用案例。

那么，究竟TPM是怎么用有限的非易失性存储空间来实现不限数量的根密钥的呢？要知道的是，一个根密钥不能存储在TPM之外的，因为它没有父密钥来加密它的私有部分。答案就是主密钥种子。

三个组织架构的每一个都和一个主密钥种子关联，分别是：背书主密钥种子，平台主密钥种子，和存储主密钥种子。这些种子一直存在于TPM设备中。它们就是密钥生成函数输入的秘密信息。当TPM创建一个主密钥时，它使用主密钥种子和一个公共模板来生成密钥。密钥模板包含了所有的密钥配置信息：密码算法和密钥长度，密钥的policy，密钥的类型（签名，加密等等）。调用者还可以在模板中添加自己的独有数据。都有数据在模板的公钥区域中添加。

密钥生成函数时固定且可重复的。对于相同的种子来说，相同的密钥模板总是会产生相同的密钥。通过改变独有数据，调用者可以创建无限多个主密钥。

当TPM创建好一个主密钥后，密钥就存储在TPM的易失性内存中。这时候用户有两种选择。通过TPM2_EvictControl将有限数量的主密钥转到非易失性的内存空间。剩下的主密钥继续保存在易失性内存中。

如果所需的主密钥数量多于TPM可以保存到持续性存储空间和易失性存储空间中的密钥数量，可以选择性地将密钥从易失性内存中清除，或者先将非易失性存储空间中的密钥移动到易失性存储空间，然后再清除。因为密钥种子时永久性的，所以密钥永远不会丢失。因为如果调用者知道可能是完全公开的密钥模板，TPM就可以在需要的时候重新创建一个完全一样的密钥。进一步讲，如果重新创建的密钥是RSA密钥，那这个过程可能需要很长时间。如果重新创建的密钥是椭圆曲线，AES，或者HMAC密钥，创建的过程就会非常快。在大多数的应用场景中，在存储组织架构下至少有一个主存储密钥是持续性存在的，它的角色和SRK类似。

在实际应用中上述的功能具体是怎样工作的呢？在TPM1.2中，有一个背书密钥和与这个密钥相关的TPM厂商签名过的证书。他们被存储在非易失性内存中，这样以来最终的用户使用包含TPM设备的系统时，它们也就同样拥有了这个背书密钥的证书，证书和密钥通常被存储在TPM的NVRAM中。在TPM2.0中，用户可以拥有多个密钥/证书对儿，TPM实现的每一中算法至少一对。但是，用户可能不想使用珍贵的持续性存储空间用户存储密钥和证书，尽管TPM可以这样做。

既然不想浪费持续性存储空间，那应该怎么办呢？一个可能的，同时也是TPM厂商期望的解决方法是，让TPM生产商使用背书密钥种子生成几个背书主密钥钥和相应的证书，密钥使用标准算法集和广为人知的模板。其中的一种密钥及其证书，比如流行的RSA-2048被存储到持续性内存中。厂商将剩下的密钥清除，但是保存相应的证书。

TCG的基础设施工作组已经定义了一些背书主密钥的模板。RSA模板使用RSA-2048，SHA-256，和AES-128。ECC模板使用NIST-P256曲线，SHA-256，和AES-128。这两种模板使用相同的授权策略，这个授权策略要求知道背书组织架构的口令。这个策略代理了背书组织架构管理员的密钥授权。模板的独有数据部分是空的。密钥属性是（参看“密钥类型和属性”小节）fixedTPM和fixedParent都为真，也就是背书密钥被期望的那样，不能被复制。userWithAuth和adminWithPolicy被指定到Policy中，这样以来密钥必须使用policy授权，而不是口令。这样也是合理的，因为TPM厂商没有办法向用户传递口令。密钥的类型是restricted decryptkey：也就是说，是一个存储密钥。

基于前面的描述，假设用户想要一个不同的主密钥。他可以将TPM厂商预置在TPM中的密钥清除，然后自己选择算法重新生成一个主密钥。

这时候神奇的事情发生了！因为密钥的种子没有变化，并且用户重新生成密钥的时候使用的模板与TPM厂商使用的相同，所以用户得到的密钥和TPM厂商之前生成的密钥相同。用户可以把密钥的公钥部分当作TPM厂商证书列表的索引。这个证书可以存储在一个公共的服务器上。这样用户就可以方便的访问证书并开始使用。这种可重复的密钥生成方式允许TPM厂商在生产TPM时就预先生成许多密钥及其证书，但是不用将所有的密钥都存储到非易失性内存中。最终的用户需要的时候可以重新生成。

需要注意的是，TPM厂商必须实现生成所有可能需要的主密钥和厂商办法的主密钥证书。种子是一种秘密信息，因为如果不是的话，厂商就不能确定一个公钥来自于厂商自己生产的TPM设备。

一旦种子被修改，主密钥就永远不能再重新生成了，TPM中所有基于这个种子的密钥都被认为是以清除的无效的。种子被修改也意味着所有厂商生成的证书也都将没有意义。因为TPM厂商为一个新的TPM背书密钥生成证书非常困难（因为这个过程通常是厂商在量产阶段批量生成的，线下可能需要特殊复杂的流程），所以修改背书组织架构的种子受控于平台组织架构，这里的平台组织架构通常是指OEM厂商。这也就意味着最终的用户很难修改这个种子。但是从另一方面讲，只要用户在密钥模板中的随便输入一些独有数据，他就可以创建和TPM厂商完全没有关系的，自己独立的背书密钥。这未尝不是一件好事。

```
应用案例：多个主密钥
用户可以拥有多个主存储密钥作为密钥组织架构的根节点。但是这些密钥不能全部存储在非易失性内存中。如果用户使用大家熟知的模板创建密钥，他可以在需要的时候重新创建这些密钥。

以上相关的TPM密令如下：
* TPM2_NV_Read：从TPM的NV区域中读取熟知的密钥模板。TPM厂商可能会事先配置几种模板（比如说，一个RSA和一个ECC），这些模板和厂商配置的证书相匹配。用户也有可能有公司级别的模板。
* TPM2_CreatePrimary：需要选择模板。
* TPM2_EvictControl：可以选择性地将密钥配置成持续存在于TPM中。尤其是对于RSA密钥来说，这样就能节省重新生成密钥的时间（前面提到了，重新生成这种密钥很费时间）。当然密钥也可以留在易失性内存种，每次上电以后重新生成它们。
```

## 密钥的持续性
用户可以通过TPM2_EvictControl命令将一个密钥有易失性内存转移到非易失性内存中，这样以来密钥就在两个上电周期之间保持加载状态。但是密钥的使用不需要将它变成非易失性的。通常情况下，我们只希望有一小部分主密钥，可能是一个组织架构一个，被转成持续性的，这样就可以省去重新生成密钥的时间，从而提升性能。

需要说明的是，背书，存储，和平台组织架构下除主密钥意外的其他密钥也可以被设置成持续性的。一个典型的应用案例是，在系统启动初期时硬盘不可用，但是这时候需要一个密钥。另外一个应用场景就是在资源受限的平台上，比如说嵌入式控制器，它可能没有外部的持续性非易失性的存储空间。

NULL组织架构下的密钥都不能被设置成持续性的。它们在重启后被清除。

虽然只有有限数量的密钥可以被设置成持续性的，但是TPM可以处理理论上无限多的密钥。因为应用程序将TPM当作密钥缓存来使用。

## 密钥缓存
对于不是主密钥的其他密钥来说，TPM就像是一个密钥缓存。具体来说，TPM2_Create命令创建一个密钥后，使用这个密钥的父密钥加密，然后向调用者返回加密过的密钥。用户会将密钥存储在TPM之外，可能是硬盘中。当用户需要使用这个密钥时，他必须使用TPM2_load密令将密钥加载到它的父密钥下。使用完成以后，用户可以使用TPM2_FlushContext命令将密钥从TPM内存中清除。这个使用过程与主密钥不同，主密钥没有父节点，他被创建以后会暂时保留在TPM中。

一个典型的硬件TPM可能会有5-10个密钥位置（槽，key slots）：密钥槽就是密钥可以加载到的TPM内存空间。TPM管理中间件负责将密钥换入换出密钥缓存。

如果你阅读第13章，你可能会发现密钥的handle没有包含在TPM授权参数中。相反授权使用的是名称。原因就是密钥缓存和密钥换入换入操作。一个平台可能有大量的应用软件相关的密钥存储在磁盘上，它们可能通过用户的handle来识别。但是这样以来handle的数量就会远远比TPM密钥槽的数量要多。当管理中间件重新加载一个密钥后，它可能会得到一个不同的handle，这个handle可能是和TPM密钥槽的空闲状态相关的，而不是用户初始的handle。因此，中间件必须替换用户handle。如果授权数据中包含了handle信息，那中间件替换handle将会导致授权失败。

你还可能会问，如果handle可以被替换，那如果我有两个密钥的授权秘密信息相同，我怎么知道中间件没有非法使用跟我想要用的密钥不同的密钥呢？这确实是TP1.2的一个潜在问题。

TPM2.0通过将名称添加到授权数据中来解决这个问题，名称就是密钥公钥部分的摘要值。这样以来中间件可以修改密钥的handle，但是不同改变密钥的名称。

根密钥和密钥缓存共同组成一个密钥树。TPM提供了四种这样的树，每一种都有不同的控制角色。这些树也叫做组织架构（等级结构）。

## 密钥授权
尽管TPM对密钥做硬件保护已相对软件生成密钥来说已经是很大的提高了，它仍然在此基础上提供很强的密钥访问控制功能。一个软件生成的密钥经常通过使用口令做访问控制来保护密钥。比如说，一个密钥可能会用口令来加密。这种保护的强度与口令本身的强度一样，所以这个密钥很容遭受线下的暴力攻击。也就是说，一旦攻击者拿到了加密过的密钥，解密这个密钥就变成了破解用于加密它的口令。密钥的所有者不能阻止一个高频率尝试口令的攻击方法。并且这种攻击可以被并行化，也就是说不同的机器同时使用不同的口令来实施破解。云服务已经让这种攻击变得非常容易了。

TPM针对软件生成的密钥做了两方面的改进。首先，当密钥离开TPM时，它会被一个强度很高的父密钥加密。这个时候攻击者需要破解一个强度很高的密钥而不是一个口令。其次，当密钥被加载到TPM中时，它还会收到字典攻击防护逻辑的保护。每一次攻击者尝试授权密钥失败时，这个逻辑就会记录下来。当失败的次数达到一定预置值时，TPM就会阻止密钥授权，并保持一段事先配置好的时间。这将很可能大大降低攻击者实施攻击的频率。这种频率限制机制可以保证即使破解一个很弱的口令也要耗费比破解软件密钥长得多的时间，因为软件的密钥没有尝试频率限制。第13章会详细介绍HMAC和口令授权。

TPM提供了许多比简单口令更丰富的访问控制机制。但是，最终还是基于硬件的字典攻击防护机制使得一个TPM密钥口令免于遭受攻击。

## 密钥销毁

## 密钥组织架构
## 密钥类型及其属性
### 对称和非对称密钥属性
### 密钥复制属性
### 受限制的签名密钥
### 受限制的解密密钥
## 上下文管理和加载
## 空组织架构
## 认证
## 密钥结构详解
## 总结
