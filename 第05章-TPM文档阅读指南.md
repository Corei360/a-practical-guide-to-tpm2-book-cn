# TPM文档阅读指南
不论使用什么方法，TPM2.0规范都是一个很难阅读的文档。尽管大部分的技术文档都很难阅读，但是TPM2.0还是有一些特别的挑战。首先这个规范很长，上次统计的时候已经超过1000页，并且因为使用过分简单和正式的语法，导致常常在一些看起来不重要的标点符号中包含了重要的功能说明。规范的第二部分能够被代码生成工具解析从而生成C语言的头文件，序列化和反序列化函数。这也解释了为什么规范中表格强调使用特殊标点符号和特别的样式。有时候一些重要的概念解释太简单并且不容易被发现。尽管从技术上来说没有问题，但是这些解释还是很难理解。文档描述的简洁和尽力避免冗余增强了文档的可维护性，但是无疑也降低了文档的可读性。实际上规范的主要目标就是可维护性，因此我们认为规范制定在这一点上做得很成功，甚至有点过了！

但是从技术的角度考虑，这个规范又是很健壮的；你需要的所有信息都在里面，问题是你要努力去找到它们。这就像是把一大堆拼图拼在一起，你有所有的拼图片，但是它们不总是在你预想的位置。这一章的目的主要是帮助你越过一些障碍从而更快地完成拼图。这些障碍是我们这些作者在这一领域研讨过的。你需要一直牢记在心的是，一旦你适应之后就会发现这个文档是很有逻辑性的。可能你并不相信，但是终有一天你会的。

总之，学习TPM2.0并不是一个简单的任务。但是幸运的是我们将帮助你大大加速学习进度。

这一章将介绍如下的主题:
* TPM2.0规范中较高层级的数据结构。
* 理解规范所必须的定义。
* 命令简要说明列表。
* 列表的修饰符。
* 命令的简要语法。
* 查找重要信息和常用信息的小窍门。
* 你需要了解的其他与TPM2.0相关的规范。
* 学习TPM2.0规范的策略。

注：这章并没有按照顺序介绍TPM规范的四个部分。顺序介绍看起来是合理的，但是我们在尝试以后得出的结论就是，这样不利于新手理解规范文档。为了提升你的理解，我们按照有助于加快你学习进程的方式修改了顺序。

## TPM2.0规范的四个部分
TPM2.0规范是TPM2.0最重要也是最基础的规范。这个规范描述了TPM2.0的核心功能。

规范一共包含如下四部分：
* 第一部分，架构：正如它的名字一样，这是规范中最重要的一部分，所以值得仔细研读。这部分描述了TPM的基本操作及其背后的原理。它还包括了很多关于TPM操作的实践细节。比如说，这部分包含了会话（session）如何创建的描述。会话被用于授权，审计，加密等命令。所以描述包含了各种类型会话的详细信息。
* 第二部分，数据结构：这部分主要描述了TPM2.0用到的数据类型，结构体和联合。这相当于一个变成手册关于数据类型的介绍。同时它还包含了命令失败时错误编码的定义。
* 第三部分，命令：这部分包含了TPM2.0所有的命令描述，相当于编程手册中函数的描述。它包含了TPM2.0所有命令的输入参数，输出参数以及错误产生的条件。同时每一个命令所做的操作细节都用C代码详细的描述。但是这些C代码会调用第三部分没有的其支撑性函数，这些函数以及相关的错误编码被包含在第四部分中。
* 第四部分，支撑性函数：这部分主要包含了会被第三部分C代码调用的函数描述以及相关的错误代码定义。这些代码包含了很多TPM2.0很多特别细致的操作。如果你需要深入TPM模拟器源码来找到一个错误码产生的原因，你应该仔细研读这一部分。所以不管用什么样的方式，你最终会在调试过程中逐渐熟悉其中重要的内容。

### 一些定义
在正式介绍每一部分之前，我们先介绍一些有助于理解规范的定义。 我们建议读者把这一部分打上标签，因为以后你在阅读规范和这本书时一定还会经常用到这些定义的。如果你在第一次学习这些定义的时候没有完全理解，也要灰心。第一次阅读的时候有一个全局性的理解就好，然后打上标记以备以后引用。

#### 常规定义
以下的定义使用于命令和命令的响应：
* 授权：用于证明拥有一个TPM资源实体的访问权限，TPM2.0有三种授权类型：
  * 口令授权：这是一种单次操作的明文授权方式：
  * HMAC 授权：使用一个HMAC来做授权操作。HMAC密钥是使用一个共享秘密生成的，共享秘密也是授权的基础。
  * 策略授权或者增强的授权：当一个授权策略的条件被满足时才能授权使用TPM的一个对象。在TPM命令被执行之前，使用策略断言命令来判断授权条件是否满足。
* 会话（session）：TPM2.0将会话定义为：一个因TPM操作产生的状态的集合。不幸的是，这个定义太抽象并不能体现有价值的信息。最好的理解会话的方法就是看看会话是怎么用的。会话被用于授权操作，并且单次命令的操作如加密，解密，审计等等都是在一个会话中完成的。对于HMAC和Policy（策略，后面都将以Policy的形式体现）会话来说，首先创建会话，然后在这个会话中执行多个命令。然而口令授权却是会话的一个特殊情况，这个会话并不包含任何TPM状态信息。不同类型的会话及其应用场景将在本章后面部分介绍。现在为止，我们已经具备足够知识来理解高层次的概念。
* Handle：它用于标识TPM资源，这个资源占用了TPM的内存。
* 字节流：对于一个TPM命令来说，就是实际发送给TPM设备的一串数据。对于命令相应来说就是从TPM设备收到的一串数据。（TPM2.0 BitProtocol了解一下）
* 标准化的数据：规范第三部分以C语言结构体的方式描述了TPM命令的输入和输出。然而这个结构体的大小通常比实际发送到TPM的数据要大。比如说，一些结构体中包含一些大小变化很大的联合体，实际运行中只有真正用到的类型才会被用到。另外，与TPM交互时数据是以大端的形式存储的。复合以上特点的数据就是标准化的数据（就是真正进出TPM设备的数据）。一个命令的字节流就是组合标准化的输入参数后形成的，命令响应也是一样的。
* 反序列化的数据：就是以C语言结构体形式存在的数据。
* 序列化的数据：标准化形式的数据，也就是进出TPM设备的数据。

#### TPM命令字节流中主要内容的定义
以下内容将按照它们在命令字节流中出现的顺序来介绍：
* Command header：是所有命令都有的区域。它包括tag，commandSize和commandCode这三个域：
  * tag：用户标识这个命令是不是有session，也就是说标识命令是否包含是授权区域。
  * commandSize：整个命令字节流的大小，包括这个header本身。
  * commandCode：标识了命令本身，它决定TPM对后续命令流如何解析。
* Handle area：包含0-3个handle
* Parameter area：包含命令相关的参数信息。
* Authorizaiton area：包含了命令的会话数据。因为一个命令可以和多大3个session相关联，所以这个区域可以包含0-3这session。session中包含了授权信息，修饰符和在应用与TPM之间传输的session状态信息。

#### TPM命令响应字节流中主要内容的定义
以下内容将按照它们在命令响应字节流中出现的顺序来介绍：
* Response header：是所有命令响应都有的区域。它包括tag，responseSize和responseCode这三个域：
  * tag：用户标识这个命令是不是有session，也就是说标识命令响应是否包含是授权区域。
  * responseSize：整个命令响应字节流的大小，包括这个header本身。
  * responseCode：标识了命令本身，它决定TPM对后续命令响应字节流如何解析。
* Handle area：包含0-3个handle
* Parameter area：包含命令响应相关的参数信息。
* Authorizaiton area：包含了命令响应的会话数据。因为一个命令可以和多大3个session相关联，所以这个区域可以包含0-3这session。session中包含了授权信息，修饰符和在应用与TPM之间传输的session状态信息。

### 从第3部分开始：命令
如果你跟大部分程序员一样，那你将会从第三部分开始。说真的，谁有时间去读一本如此之长的规范文档呢？毕竟我们的目标就是完成任务，对吗？（真的对吗？）事实上这对于忙碌的工程师来说就是如此。实际上这是一种很好的方法，当然你马上就会不得不面对TPM2.0规范确实难以阅读这个残酷的现实。为了帮助你越过我们在使用规范时已经经历过的障碍，你首先要了解以下关于第三部分的事情。

TPM2.0通用的命令和命令响应相关的数据结构是在规范第一部分介绍的，章节的名称叫做“Command/Response Structure”。其中的分割列表，命令结构和命令响应结构列表都非常有用。我们建议将规范的这个位置加上标签，因为以后你会经常用到的。

为了能让我们介绍的内容更具实践性，我们首先详细介绍两个命令。不需要授权的TPM2_Startup和需要授权的TPM2_Create。并且说明这两种类型命令在字节流中的差别。我们首先介绍TPM2_Startup，因为这个命令是TPM第一个必须要执行的命令，也是TPM2.0中最简单的命令之一。

如果你查看第三部分有关TPM2_Startup这个命令的内容，你将看到以下三个部分：
* “一般描述”：简要说明命令的功能，详细描述一些重要的输入约束，以及相关的错误条件。
* “命令和响应”：一个描述命令输入和输出数据的列表。我们马上就会介绍这个。
* “详细的动作”：包含命令的实现代码和标识错误条件的列表。（不包含支撑性代码的错误信息）

所有命令都使用这种三段式的描述。我们现在只看命令和响应列表。对于TPM2_Startup来说，这些列表分别是表5-1和表5-2。

表5-1

最左边的类型（Type）一列表示命令相关参数的数据类型。这些数据类型是在规范的第二部分定义的。名称（Name)这一列是自注释的，主要包含了进出TPM设备的参数名称。同时这也名称与第三部分的源码相对应。描述（Description）这一列简要描了这个域的功能及其特殊要求。TPM2_Startup有两个跟域相关的要求：tag域必须是TPM_ST_NO_SESSIONS，commandSize域必须是TPM_CC_Startup。“{NV}”是一个列表修饰符，它表示这个命令有可能会更新TPM内部的NVRAM。（列表修饰符在规范第三部分比较靠前的位置描述）

所有命令的前三个域，也就是tag，commandSize和commandCode，是相同的。这三个域一起构成了命令的头。

下面是这个命令各个域的详细解释：
* tag：标示了这个命令是否有会话。因为TPM2_Startup从来不使用会话，所以这个值必须是TPM_ST_NO_SESSIONS。
* commandSize：整个命令数据流的大小。
* commandCode：标示要执行哪一个命令。它决定TPM怎样处理后续的数据。

现在注意看一下commandCode之后的这条线：

线

这条线之后的域都是命令的参数区域。在这个例子中，startupType是这个区域中唯一的参数。通常情况下，这个区域包含了一些和具体命令相关的配置参数。这个区域内的其他线条修饰和列表修饰符分别在规范第三部分的“Table Decorations”和“Handle and Parameter Demaraction”中描述。当你阅读第三部分的时候会经常饮用这一部分的。

表5-2


下面是这个命令响应各个域的详细解释：
* tag：标示了这个命令响应是否有会话。因为TPM2_Startup从来不使用会话，所以这个值必须是TPM_ST_NO_SESSIONS。
* commandSize：整个命令响应数据流的大小。
* commandCode：标示了这个命令执行成功与否。TPM_RC_SUCCESS表示成功，其他值表示失败。

主要注意的是TPM2_Startup没有参数返回，所以列表中也就 没有用于标示参数的线。

现在我们将了解比前一个复杂的多的命令TPM2_Create。这个命令用于创建TPM对象，比如密钥和其他数据对象。表5-3就是它的命令描述表。

表5-3

下面是这个命令各个域的详细解释：
* tag：在这个例子中，它的值是TPM_ST_SESSIONS。它表示这个命令必须包含会话。另外列表中parentHandle前面的@符号也说明了这一点，同时也就意味着这个命令的授权会话与这个handle相关。后续会更详细地介绍。
* commandSize：整个命令数据流的大小，包括授权数据。
* commandCode：标示要执行哪一个命令。它决定TPM怎样处理后续的数据。

现在需要注意下面这个分隔符，有趣的是，TPM2_Startup中没有这样的分隔符。

分隔符

这个分隔符后面的区域就是handle区域，规范的第三部分“Handle and Parameter Demacration”这一节会介绍。Handle就是一个32位的整数引用，用于标示TPM内部的资源实体。对于这个命令来说，parentHandle是它用到的唯一的handle。一个命令最多可以用两个handle。

这里再次注意一下parentHandle前面的@字符。它是一个列表修饰符，它表示parentHandle要求这个命令的授权数据区域中包含它的授权信息。

同样注意一下在描述这一列中的“Auth Index: 1”。它标示了这个handle相关的授权信息在授权区域内的顺序。在这个例子中，parentHandle的授权信息必须出现在授权区域的第1个位置。所有需要授权信息的命令最多可以包含3个授权信息。强调一下，当命令的描述表中的handle使用@修饰时就表示这个命令需要这个handle相关的授权信息。在这个例子中只需要一个授权信息。

然后我们再看一下Auth Role: USER，这是授权的进一步限制，在增强的授权一章会有详细的介绍。Auth Role与操作系统中的权限级别类似。它控制着谁可以访问TPM特定的资源实体。

Handle和命令参数区域的使用方式不同，handle不会用于计算cpHash，cpHash就是输入参数的哈希。这个哈希值又会用于计算HMAC值，有时候也会用于计算Policy摘要。正因为handle不用于计算cpHash，用于TPM的资源管理软件就可以将handle虚拟化，从而实现TPM对象的换入换出。这一点与虚拟内存在磁盘和物理内存之间换入换出原理类似。后续的章节将详细介绍HMAC，Policy摘要以及资源管理。现在为止，我们需要理解，handle和参数在最终的字节流中是分开来放的，这样以来就可以实现一些重要的（管理）功能。

接下来我们又看到了与Startup命令一样的分割线，它同样也是表示参数区域的开始。

线

但是在这个示例中，因为tag的值是TPM_ST_SESSIONS，就是说这个命令需要授权会话。所以这个分割线也同事代表了授权数据在命令字节流中的位置。这个命令的授权区域可以包含1-3个会话。我们会在第13章详细介绍授权区域。

这个命令需要四个参数：insensitive，inPublic，outsideInfo和creationPCR。规范的第二部分描述了参数对应的数据结构。

表5-4是TPM2_Create命令的响应描述表。

表5-4

下面是这个命令相应的各个域的详细解释：
* tag，responseSize和responseCode已经在之前的示例中说明了。当然不同的是，如果命令成功了，tag的值是TPM_RC_SESSIONS而不是TPM_ST_SESSIONS，它用于表示在命令响应的会话。实际上，抛开本例，总结一下一共有以下三种情况：
  * 如果命令没有会话，那么响应也不会有。这样的命令里，tag的值永远是TPM_ST_NO_SESSIONS。
  * 如果命令有会话，并且命令也执行成功了，那么命令相应的tag值就是TPM_ST_NO_SESSIONS。这表示命令的相应也包含会话信息。
  * 如果命令有会话，但命令执行失败了，那么响应的tag值就是TPM_ST_NO_SESSIONS。进一步说，一个失败的命令响应从来都不会包含会话或者响应参数。

当命令的响应描述中包含下面的分割线时，就表示之后是handle区域。在这个命令中，没有命令响应handle，所以也没有这个分割线。

分割线

现在有看到用于表示参数开始的老朋友了。

参数分割线

但是需要特别注意的是，命令响应中的分割线仅仅用于表示它后面的内容是命令响应的参数。命令相应的授权信息不在这里，而是在字节流靠后的位置。这个命令一共有5个返回参数：outPrivate，outPublic，creationData，creationHash，和creationTicketNotice。

命令响应的授权信息出现在所有参数之后的最后一个分割线之后。这也就意味着命令响应的授权数据在整个响应字节流的最后位置。

到现在为止我们介绍了命令和命令响应的整体结构，下面我们讨论一下常用的数据类型。

### 数据结构详解
如果你正在编写底层的TPM代码，理解这一小节很重要，因为代码大部分的bug将来自这里。当调试TPM2.0底层代码时，你需要理解这一节，从而对进出TPM设备的字节流解码。通用数据结构的构造，字节流的标准化，和大小端是理解这一节的重要数据概念。

#### 通用数据结构组成
这一小节将介绍一些常用的数据结构。因为我们以后将经常看到这些结构，所以理解它们是很重要的。

##### 以TPM2B_开始的数据结构
所有以“TPM2B_”开始的数据结构都是以字节为单位的buffer。每个这样的buffer都由size和array[size]构成。表5-5就是一个典型的结构。

表5-5

与它相对应的C语言结构如下：
'''
typedef struct {
UINT16 size; /* size in octets of the buffer field;
may be 0 */
BYTE buffer[sizeof(TPMT_HA)]; /* the buffer area that contains the
algorithm ID and
the digest */
} TPM2B_DATA;
'''

#### 包含联合的结构体
#### 数据标准化
#### 大小端模式
### 第2部分：注释语法

### 第3部分：列表修饰符
### 常用的规范章节
### 怎样在规范中获取信息
### 加速TPM2.0发展的战略
#### Will
#### Ken
#### Dave
### 其他与TPM2.0相关的规范
### 总结
    
