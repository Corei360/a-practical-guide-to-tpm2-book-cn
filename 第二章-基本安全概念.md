# 基本安全概念  
这一章主要介绍基本的安全概念和它们在TPM中的应用。因为从应用的角度来说，理解这些概念背后的数学原理并不重要，因此我们也不做过多介绍。相反，我们会更多的讨论各种密码学算法的行为，从而帮助你理解TPM2.0规范是如何使用这些算法的。

安全专家可以忽略这一章。如果你已有零碎的相关知识，建议你浏览一遍从而让你回复记忆或者理解TPM如何利用基本的密码学概念。如果你对密码学或者TPM一点概念都没有，这一章必读哦。

TPM2.0规范中使用的所有密码学算法都是基于公开标准的算法，并且这些算法都被广泛地评审过。从头设计一个定制化的具有相当密码学强度的算法是非常困难的。一个密码学算法只有在经过长时间的密码学分析之后才有可能被认定为是高强度的，同时只有满足一定规则要求的算法才会被TCG允许在TPM规范中使用。这一章将介绍三种类型的算法：用于完整性的哈希算法，用于保密性的对称加密算法，用于数字签名和密钥管理的非对称加密算法。具体来说，我们将讨论安全哈希算法，AES（Advanced Encryption Standard）以及两种非对称密码标准：RSA和椭圆曲线密码（ECC）。在介绍具体的算法之前，我们首先要知道它们分别用于防护什么。

我们以两种攻击类型的描述来开始本章：暴力攻击和密码分析。然后定义一些基础的概念：消息，秘密，完整性，认证和授权，同时附带两个高层的概念，防止重放攻击和不可抵赖性。最后，分别列出TPM使用的密码学算法。

首先，内容最多的一部分是通用的安全规则。因为这些规则贯穿于本书以及TPM的设计中，我们将详细描述这些规则在TPM2.0中的特定应用来加深理解。通常情况下，TPM以常用的方式使用密码学算法，如果有什么例外，我们将在这里解释。（以extend操作为例，它是一个通用的安全概念，TPM以一种全新的方式来使用它）

需要说明的是，TPM规范中做的每一件事情都是为了减少密码攻击的可能性。

## 密码攻击
密码学因阻止攻击者作恶而生。一个基于密码学的安全系统用于阻止心怀恶意的人盗取你的数据，冒充你，或者在你没有察觉的情况下修改你的文档。攻击者通常通过两种方式破坏密码设计的安全性：深入理解密码和协议背后的数学原理来寻找漏洞，或者暴力破解。

如果你使用经过完善审查的算法和协议，同时遵守它们的使用方式，你的设计在很大程度上不会遭受第一种类型的攻击。而暴力攻击不同，攻击者使用每一个可能的密钥，输入，或者口令试图猜测用于保护系统设计的秘密信息。

### 暴力破解
密码学家通常不会声明一件事情不仅可能发生。他们总是说这个事情“计算上不可行”，意思是说攻击一个密码需要不切实际的大量时间来尝试每一中可能的组合。以DES（Data Encryption Standard）为例，一共有2的56次方个可能的密钥。这个数目是72,057,594,037,927,936，哇哦。破解DES算法尽管看起来在计算上不可行，它最终还是在1998年被一台特别制作的机器破解（wiki）。

口令也经常被暴力破解。首先是尝试单词字典，然后是单词，数字甚至是特殊符号的组合。奇葩的是攻击者甚至可以使用Klingon和The Lord of the Rings书中的单词来破解，RainbowCrack就是一个为人熟知的暴力破解的例子，即使你的口令很长也无济于事。

如果一个密码算法的安全强度不依赖算法实现细节的保密，那就认为它是一个好的算法设计。当一个算法不能通过猜测它的密钥来破解时，它就是不可攻破的。防止暴力破解最主要的两种方式是：选择足够长的密钥使破解在计算上不可实现，或者想办法限制攻击者在一定时间内尝试次数。

TCG假定所有它采用的算法都是经过良好设计的。这个假设不一定是绝对正确的，因为并不是每一种算法都是经过广泛的实际验证的（前文只是说，每一种算法都经过很详尽的算法分析）。当然规范的算法灵活性也保证了如果将来的某一天TPM采用的一种算法被证明是不安全的，那也只是需要把这个算法从可允许使用的算法列表中删除，而不是重写规范。

密码算法本身的强度体现在它对数学原理层面攻击的免疫力，而一个算法的应用实现强度则和算法类型以及密钥大小的选择息息相关。

#### 根据类型来计算算法强度
对称算法使用同一个密钥来做加解密操作，它是一种传统的加密方式。对于一个设计良好的对称密码算法来说，它的强度与所使用密钥的长度成指数关系。举例来说，如果一个密钥只有4比特长，那一共只有16种可能的密钥。一个暴力攻击者经过16次尝试后一定可以破解这个密钥。因为密钥的选择是一个随机的过程，通常来说平均需要尝试密钥空间大小一半的次数就可以找到正确的密钥，在这个例子中也就是平均尝试8次就可以破解。因为密码强度与密钥的比特位数成指数关系，我们通常使用密钥的比特位数来表达一个算法的强度。具体来说，对称密码算法的轻度就是密钥的比特位数。在TPM规范中，对称密经常使用的密钥长度是128，192，256比特。

安全哈希算法只能加密不能解密。这听起来好像没有什么用处，但是事实上它有很多种有意思的应用。哈希算法的一个重要特点是，无论输入的长度是多少，它总是产生相同长度的输出。更加有趣的是，不能解密意味着给你一个哈希算法的输出，你不能反推出它的输入是什么。这种算法的强度体现在以下两个方面：

* 能够产生给定的哈希输出值之前尝试的次数。对于一个设计良好的哈希算法来说，这个次数值是该算法输出比特长度的指数（2^）
* 当两个不同的输入产生相同输出的概率为50%之前需要尝试的次数。对于一个设计良好的额哈希算法来说，这个次数值应该是算法输出长度一半的指数(2^).(具体的原因译者也不是很清楚其数学原理，看原文或者google一下birthday attack吧)

哈希算法的使用多种多样，但是因为密码学者通常有三类人-职场人士，专家，幻想狂，通常最后一种人的使用方式被认为是设计良好的使用方式，穷尽一切可以想到的方法来减小被攻击的可能性，你懂得。

非对称算法给人的第一感觉是很奇怪，它的加密和解密使用不同的算法，不同的密钥。不同的密钥-公钥和私钥，共同组成了非对称算法的密钥对儿。稍后我们将在本章介绍两种你需要关心的两种非对称算法：RSA（自行搜索）和椭圆曲线密码（ECC）。

对于非对称密码来说，很难通过其密钥长度来计算算法强度。如果是RSA算法，我们有相关的列表可供参考。这个表会列出2048位的RSA密钥强度与112位的对称密钥强度相当，3076位，15360位分别与128位，256位的强度相当等等诸如此类的关系。对于ECC来说，其强度与密钥长度是其一半的对称算法相当。例如256比特，384比特密钥强度分别与128位，192位的对称算法密钥强度相当。

如果攻击者因为密钥长度太长而无法实现暴力破解时，他们就可能尝试分析算法的数学原理来挖掘可能的漏洞，从而实现破解。

### 针对算法本身的攻击
密码算法的设计有一定程度的艺术性。算法背后的原理通常用于解决一类特定的问题，反过来其难度也受限于设计者当前的认知。事物总是在不断的发展变化，所以很难设计一种可以免受任何攻击的算法。

前文也有提到，针对SHA-1的攻击直接推动了TPM由1.2版本向2.0版本过度。在通常情况下，暴力生日攻击破解SHA-1算法大概需要2的80次方的尝试。针对算法数学原理的攻击可以将所需的攻击次数降低到2的63次方，就是说将SHA-1的80比特位的强度降低到63位。SHA-1算法贯穿TPM1.2的设计，随着56比特位强度的DES加密算法在1998年被破解，工业界也认识到可以被降低到63位强度的SHA-1算法时不够的。正因为如此，TPM2.0的设计消除了对SHA-1的依赖。正如前文所述，TPM2.0被设计成算法可以灵活配置，并且不需要修改规范。

总结来看，为了保持安全性，密码算法必须不能有以下两种漏洞：
* 算法本身的强度不够，可以通过选择被广泛审查和应用的算法标准。
* 不能抵御暴力攻击，主要是通过选择更长的密钥来解决。目前通常情况下128位的对称算法被认为是安全的，但是一些研究人员坚持192位才足够安全。

到现在为止你已经看到了将要应对的攻击，接下来我们将介绍基本的密码学概念。首先，介绍一些基础定义。

## 安全的定义
以下涉及的一些定义对于理解TPM的架构和密码学概念非常重要。人们常常将安全仅仅视为保密，也就是说如果攻击者不能拿到你的私密信息就是安全的，这显然是不正确的。尽管尽管保密非常重要，但是安全远远不止于保密。通过一个实际的例子就能理解为什么。因为TPM设计的一个重要驱动力来自于电子商务，所以下面我们将引出一个电子商务的概念来详细说明。

在电子商务交易中，消费者会向商家发送一个电子订单。消费者和商家都希望保证交易过程中的私密信息（信用卡号等等）是安全的。但同时商家也希望保证消费者不是恶意的攻击者，消费者也希望只有真正的商家能收到自己的订单；同时还要求电子订单不能再传输过程中被修改（比如修改订单中商品的数量），并且同一个订单不能被多次发送。另外，商家也可能需要对消费者的消费行为进行限制，比如订单消费的总量等。密码学和安全传输协议试图努力解决所有以上的电子商务问题。

基于上面的例子，我们引出一些常用的安全概念，并解释他们分别应用于安全的方方面面。

* 消息：交易或者通信双方产生的一个数据流。
* 保密：一种防止未授权的观察者辨识消息内容的方法。
* 共享秘密：双方都知道的一个值。这个秘密可以是口令或者是加密密钥。
* 完整性：用于指示消息在存储或者传输中没有被篡改。
* 认证：一种可以证明一个消息只能来自一个特定的消息创建者的方法，因此接受者可以通过这个方法认定消息的创建者发送了这个消息。
* 授权：一个可以表明用户具有某种操作权限的证明。
* 防止重放：一种防止攻击者重复利用有效信息的方法。
* 不可抵赖：一种可以阻止一个消息的发送者否认发送了该消息的方法。

现在我们来说明一下这些概念是怎样在电子交易中被应用的。消息就是订单的内容，它包含了商品的数量和顾客的机密信息，比如信用卡卡号。完整性能够保证订单作为消息在传输过程中没有被篡改，比如商品数量由3被修改成300。商家通过对订单发送者进行身份认证来确认订单确实来自一个真是顾客而不是攻击者。同时商家可以基于公司利益的考虑决定顾客是否有订单相关商品的购买权限。如果攻击者多次将顾客的订单发送给商家，就会造成双方的经济损失。防止重放的方法可以阻止攻击者重复发送订单。不可抵赖的方法可以保证顾客在确认订单以后就不能否认自己曾经下过单这个事实。

安全系统的设计者为了满足上述的安全特性需求制定了密码学工具箱，并仔细分析改进和促使它们标准化。这其中有一些由基础的数学运算构成，比如说SHA-256哈希运算和RSA加解密运算。而另外一些则是在前者的基础上构建而成，比如数字签名就应用了RSA算法。接下来我们将逐一介绍。

## 密码家族
首先要声明的是这一节没有数学相关的内容。我们也不会描述素数算法和椭圆曲线。但是理解一些密码学的基本运算以及这些运算和我们已经了解到的安全概念的关系是非常重要的。

概括来说，哈希算法用于提供完整性。同时哈希可以和一个共享秘密组合成HMAC来实现认证。HMAC反过来又是密码学凭据和密钥生成器的基础。对称加密中会使用共享的秘密作为加解密密钥。随机值则用于防止重放。非对称密钥常作为签名密钥来保证不可抵赖性。TPM也会使用非对称密钥来加密一些通信协议。接下来我们将逐一介绍。

### 哈希（摘要）
大多数的计算机专业学生对哈希都很熟悉；简单的哈希经常用于加速搜索，更加高级一点的哈希用于检测数据错误。但是密码学习中的哈希因为要用于防止攻击者破坏系统，所以密码学家会给这种哈希算法增加一些非常特殊的特性。


### 哈希扩展（HashExtend）
### 基于哈希的消息认证码（HashedMessageAuthenticationCode)
### 密钥生成器（KeyDerivationFunction）
### 认证或者授权凭据
### 对称机密密钥
#### 对称密钥的模式
### 随机值
### 非对称密钥
#### RSA非对称密钥算法
##### RSA用于密钥加密
##### RSA用于数字签名
#### ECC非对称密钥算法
##### ECDH用于密钥交换
##### ECDSA用于数字签名
## 公钥证书
## 小结
