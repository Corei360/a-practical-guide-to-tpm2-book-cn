# 基本安全概念  
这一章主要介绍基本的安全概念和它们在TPM中的应用。因为从应用的角度来说，理解这些概念背后的数学原理并不重要，因此我们也不做过多介绍。相反，我们会更多的讨论各种密码学算法的行为，从而帮助你理解TPM2.0规范是如何使用这些算法的。

安全专家可以忽略这一章。如果你已有零碎的相关知识，建议你浏览一遍从而让你回复记忆或者理解TPM如何利用基本的密码学概念。如果你对密码学或者TPM一点概念都没有，这一章必读哦。

TPM2.0规范中使用的所有密码学算法都是基于公开标准的算法，并且这些算法都被广泛地评审过。从头设计一个定制化的具有相当密码学强度的算法是非常困难的。一个密码学算法只有在经过长时间的密码学分析之后才有可能被认定为是高强度的，同时只有满足一定规则要求的算法才会被TCG允许在TPM规范中使用。这一章将介绍三种类型的算法：用于完整性的哈希算法，用于保密性的对称加密算法，用于数字签名和密钥管理的非对称加密算法。具体来说，我们将讨论安全哈希算法，AES（Advanced Encryption Standard）以及两种非对称密码标准：RSA和椭圆曲线密码（ECC）。在介绍具体的算法之前，我们首先要知道它们分别用于防护什么。

我们以两种攻击类型的描述来开始本章：暴力攻击和密码分析。然后定义一些基础的概念：消息，秘密，完整性，认证和授权，同时附带两个高层的概念，防止重放攻击和不可抵赖性。最后，分别列出TPM使用的密码学算法。

首先，内容最多的一部分是通用的安全规则。因为这些规则贯穿于本书以及TPM的设计中，我们将详细描述这些规则在TPM2.0中的特定应用来加深理解。通常情况下，TPM以常用的方式使用密码学算法，如果有什么例外，我们将在这里解释。（以extend操作为例，它是一个通用的安全概念，TPM以一种全新的方式来使用它）

需要说明的是，TPM规范中做的每一件事情都是为了减少密码攻击的可能性。

## 密码攻击
密码学因阻止攻击者作恶而生。一个基于密码学的安全系统用于阻止心怀恶意的人盗取你的数据，冒充你，或者在你没有察觉的情况下修改你的文档。攻击者通常通过两种方式破坏密码设计的安全性：深入理解密码和协议背后的数学原理来寻找漏洞，或者暴力破解。

如果你使用经过完善审查的算法和协议，同时遵守它们的使用方式，你的设计在很大程度上不会遭受第一种类型的攻击。而暴力攻击不同，攻击者使用每一个可能的密钥，输入，或者口令试图猜测用于保护系统设计的秘密信息。

## 暴力破解
密码学家通常不会声明一件事情不仅可能发生。他们总是说这个事情“计算上不可行”，意思是说攻击一个密码需要不切实际的大量时间来尝试每一中可能的组合。以DES（Data Encryption Standard）为例，一共有2的56次方个可能的密钥。这个数目是72,057,594,037,927,936，哇哦。破解DES算法尽管看起来在计算上不可行，它最终还是在1998年被一台特别制作的机器破解（wiki）。

口令也经常被暴力破解。首先是尝试单词字典，然后是单词，数字甚至是特殊符号的组合。奇葩的是攻击者甚至可以使用Klingon和The Lord of the Rings书中的单词来破解，RainbowCrack就是一个为人熟知的暴力破解的例子，即使你的口令很长也无济于事。

如果一个密码算法的安全强度不依赖算法实现细节的保密，那就认为它是一个好的算法设计。当一个算法不能通过猜测它的密钥来破解时，它就是不可攻破的。防止暴力破解最主要的两种方式是：选择足够长的密钥使破解在计算上不可实现，或者想办法限制攻击者在一定时间内尝试次数。

TCG假定所有它采用的算法都是经过良好设计的。这个假设不一定是绝对正确的，因为并不是每一种算法都是经过广泛的实际验证的（前文只是说，每一种算法都经过很详尽的算法分析）。当然规范的算法灵活性也保证了如果将来的某一天TPM采用的一种算法被证明是不安全的，那也只是需要把这个算法从可允许使用的算法列表中删除，而不是重写规范。

密码算法本身的强度体现在它对数学原理层面攻击的免疫力，而一个算法的应用实现强度则和算法类型以及密钥大小的选择息息相关。

## 根据类型来计算算法强度
对称算法使用同一个密钥来做加解密操作，它是一种传统的加密方式。对于一个设计良好的对称密码算法来说，它的强度与所使用密钥的长度成指数关系。举例来说，如果一个密钥只有4比特长，那一共只有16种可能的密钥。一个暴力攻击者经过16次尝试后一定可以破解这个密钥。因为密钥的选择是一个随机的过程，通常来说平均需要尝试密钥空间大小一半的次数就可以找到正确的密钥，在这个例子中也就是平均尝试8次就可以破解。因为密码强度与密钥的比特位数成指数关系，我们通常使用密钥的比特位数来表达一个算法的强度。具体来说，对称密码算法的轻度就是密钥的比特位数。在TPM规范中，对称密经常使用的密钥长度是128，192，256比特。

安全哈希算法只能加密不能解密。这听起来好像没有什么用处，但是事实上它有很多种有意思的应用。哈希算法的一个重要特点是，无论输入的长度是多少，它总是产生相同长度的输出。更加有趣的是，不能解密意味着给你一个哈希算法的输出，你不能反推出它的输入是什么。这种算法的强度体现在以下两个方面：

* 能够产生给定的哈希输出值之前尝试的次数。对于一个设计良好的哈希算法来说，这个次数值是该算法输出比特长度的指数（2^）
* 当两个不同的输入产生相同输出的概率为50%之前需要尝试的次数。对于一个设计良好的额哈希算法来说，这个次数值应该是算法输出长度一半的指数(2^).(具体的原因译者也不是很清楚其数学原理，看原文或者google一下birthday attack吧)

哈希算法的使用多种多样，但是因为密码学者通常有三类人-职场人士，专家，幻想狂，通常最后一种人的使用方式被认为是设计良好的使用方式，穷尽一切可以想到的方法来减小被攻击的可能性，你懂得。

非对称算法给人的第一感觉是很奇怪，它的加密和解密使用不同的算法，不同的密钥。不同的密钥-公钥和私钥，共同组成了非对称算法的密钥对儿。稍后我们将在本章介绍两种你需要关心的两种非对称算法：RSA（自行搜索）和椭圆曲线密码（ECC）。

对于非对称密码来说，很难通过其密钥长度来计算算法强度。如果是RSA算法，我们有相关的列表可供参考。这个表会列出2048位的RSA密钥强度与112位的对称密钥强度相当，3076位，15360位分别与128位，256位的强度相当等等诸如此类的关系。对于ECC来说，其强度与密钥长度是其一半的对称算法相当。例如256比特，384比特密钥强度分别与128位，192位的对称算法密钥强度相当。

如果攻击者因为密钥长度太长而无法实现暴力破解时，他们就可能尝试分析算法的数学原理来挖掘可能的漏洞，从而实现破解。

## 针对算法本身的攻击
密码算法的设计有一定程度的艺术性。算法背后的原理通常用于解决一类特定的问题，反过来其难度也受限于设计者当前的认知。事物总是在不断的发展变化，所以很难设计一种可以免受任何攻击的算法。

前文也有提到，针对SHA-1的攻击直接推动了TPM由1.2版本向2.0版本过度。在通常情况下，暴力生日攻击破解SHA-1算法大概需要2的80次方的尝试
