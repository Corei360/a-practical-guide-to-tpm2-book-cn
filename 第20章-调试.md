# 调试
我至今仍记得刚开始使用Z80汇编语言编程时的情景：有好几次，仅仅是为了得到回应，我会吹牛说我能一次就写出没有问题的代码。只需要写出来，编译，瞧，多么完美的程序！说实话，在30多年的工作经历中，结果是我经常被毫无非议地嘲笑了，我从来没有实现过之前吹过的牛皮，很可能永远也不会了

Will Arthur，在写作本章时的回忆。

某个地方的某个人可能写了一个很重要的程序，并且在第一次就成功运行没有任何问题，如果真得存在这种可能，那它也就是存在于统计学上。因为编写程序的过程也可以认为是编写bug的过程，在编程世界中调试需求是永恒不变的规则。

这一章的目的是给你介绍一些用于TPM2.0程序调试和通用调试的特殊工具和方法。我们将主要讨论两个方面的调试：与TPM直接通信的底层软件和使用FAPI和TPM通信的高层次软件。底层应用包含使用ESAPI和SAPI，特殊定制的TSS软件层（如SAPI层），TAB，以及RM的软件。大多数的底层应用调试描述都是直接来自于对应部分作者的底层应用调试经验，这包括SAPI，TAB，RM，以及TPM2.0设备驱动，和所有底层相关的软件。因为现在没有TSS软件栈中FAPI和ESAPI的实现（注：ESAPI已经可以用了哦），所以没有这些方面的调试知识。也正因为如此，这一章的内容都是基于TSS1.2的调试经验，因为我们认为许多问题都是类似的，与版本关系不大。

## 底层应用软件调试
因为我们在TPM2.0方面仅在底层软件上有实际经验，我们先来讨论这些内容。

### 问题
当TPM出现一个错误的时候，它会返回一个错误代码。TPM2.0规范的编写者用心设计了这些有助于调试的错误代码。很多时候，错误代码会告诉你确切的错误原因，但是因为对规范不熟悉，你可能会感到一团糟。在少数情况下，错误代码仅仅提示查找问题的大方向，但是并没有定位错误的具体粒度信息。不论是上面的哪种情况，缺乏具体信息或者是对规范不熟悉，你作为一个经验不多的程序员都会感到不知所措。

这一小节描述了一小部分不同的错误条件，并说明了一个用于调试这些问题的技术框架，由简到繁地介绍如下：
* 错误代码分析：许多简单的错误完全可以通过这种方式调试。
* 分析调试跟踪信息：这就需要检查底层驱动来将发送到TPM的命令字节流和由TPM收到的命令响应数据流。经常发生的情况是，对比正常的跟踪数据和有问题的数据就可以很快定位问题。
* 更加负责的问题：这些问题将需要更多的工作来调试。一个HMAC授权错误可以很快产生一个错误代码，但是调试这个错误需要详细检查计算HMAC的所有步骤。
* 最难调试的错误：这些错误需要深入到TPM2.0模拟器中，并使用调试器单步调试从而理解TPM具体在哪里产生错误。通常情况下，调试TPM模拟器的代码之后，问题的答案就显而易见了。当然，更好地理解规范也有助于发现问题。人类的本性是，我们经常因为森林而分心，从而忘记应该砍下哪一棵树（意思就是我们常常迷失在上千页的规范中，不知所踪）。因此，使用调试器来调试模拟器的技术还是需要的。在Intel开发TPM2.0相关代码的过程中，本小节的作者曾经使用这个方法为自己和同事调试了许多错误。

### 分析错误代码
当你拿到一个错误代码时首先要做的就是解析它。解析的过程在TPM2.0规范第1部分的“Response Code Details”一节有介绍。这一小节中的“Response Code Evaluation”流程图特别有用。

第一个错误案例与TPM2_Startup命令相关。以下的代码片段会产生一个错误（这个代码是第7章中TPM2_Startup测试代码简单修改的版本）：

```
rval = Tss2_Sys_Startup( sysContext, 03 );
CheckPassed(rval);
```

代码在执行CheckPassed时会失败，因为TPM2_Startup命令返回了错误代码0x000001C4而不是TPM2_RC_SUCCESS。根据之前提到的流程图，你可以按照以下方式解析这个错误代码：

```
Bit 8: 1
Bit 7: 1
Bit 6: 1
```

上述这些比特位表示错误码位于比特5：0，并且错误参数在比特11：8中，根据TPM2.0规范第1部分的“TPM_RC Values”小节的描述，具体的错误值是TPM_RC_VALUE。关于这个错误的文字描述是“值超出范围或者在当前上下文中这个值不正确”。这就意味着命令的参数1是错误的。查看TPM2_Startup命令的描述之后，很容易发现，这个命令允许的参数是TPM_SU_CLEAR(0x0000)和TPM_SU_STATE(0x0001)。显然，使用0x3作为命令参数是错误的来源。

我们强烈鼓励大家使用一个解析错误的工具（tpm2-tools工程下已经有很好用的错误解析工具了），因为手动解析错误在反复的调试中很伤脑筋。一个工具的示例输出如下：
```
>tpm2decoderring /e 1c4
ERROR: PARAM #1, TPM_RC_VALUE: value is out of range or is not correct for the context
```

### 调试跟踪分析
很多时候，因为缺乏TPM知识，或者有时候错误比较晦涩难懂，仅仅分析错误代码是不够的。另外，如果一个程序以前能工作，那用这个程序的运行输出与当前出问题程序的输出做比较，这有可能更快地发现错误。基于这个原因，我们强烈推荐为TPM设备驱动增加打印命令数据以及命令响应数据的代码。这个工具在过去两年的TPM2.0开发工作中帮我节省了几个星期的时间。

针对之前的代码示例，一个正常运行的程序中命令的跟踪信息转储（dump）如下：
```
Cmd sent: TPM2_Startup
Locality = 3
80 01 00 00 00 0c 00 00 01 44 00 00
Response Received:
80 01 00 00 00 0a 00 00 00 00
passing case: PASSED!
```
一个不正常的程序的跟踪信息转储如下：
```
cmd sent: TPM2_Startup
Locality = 3
80 01 00 00 00 0c 00 00 01 44 00 03
Response Received:
80 01 00 00 00 0a 00 00 01 c4
passing case: FAILED! TPM Error -- TPM Error: 0x1c4
```

使用一个好用的表工具就能够很快地发现出错命令数据中不正确的值，00 03。

上述方法的一个警告是， TPM的很多输出都是随机的，并且这些随机的输出又常常反过来作为其他命令的输入。这就意味着，在用可视化工具比较不同时，你需要忽略这些转储中的这些随机数据。经验将会帮助你快速定位哪些内容需要忽略，哪些应该集中关注。这实际上并没有听起来这么难。

另外一种使用跟踪信息转储的方式是，比较多种来自不同软件层级的跟踪信息。比方说，你可能会有一个针对ESAPI层的跟踪转储，一个来自于驱动层的跟踪转储，甚至是一个来自于TPM模拟器的跟踪转储。有时候将这几种转储信息同步起来就很有挑战性。因为会话nonce是随机的，唯一的，并且无论它们出现在哪一层软件中，值都是一样的，因此会话nonce可以用于同步这几种转储信息。首先在一个跟踪转储信息中找到一个nonce值，然后在其他跟踪转储中搜索这个唯一的nonce值。

### 更加复杂的错误
一个更加复杂的错误例子是关于HMAC授权的错误。这个错误是由错误代码TPM_RC_AUTH_FAIL来指示的。这个错误代码的描述是“HMAC授权检查失败，并且DA计数器加1”，错误代码中的高比特位指明了是哪一个会话中出现了这个HMAC错误。

不幸的是，调试这个错误并不容易。计算HMAC需要很多步骤：秘钥生成，输入输出参数做哈希，以及HMAC计算。上述步骤中又有很多输入参数：nonce，秘钥，以及授权会话类型等。这些数据中的任何一个出错，或者生成HMAC的步骤出错，都将导致HMAC不正确。

我们发现，唯一能够高效调试这些错误的方式是，增强代码的调试跟踪能力，将所有用于米哟啊生成，哈希，以及HMAC计算的输入输出信息打印出来。然后小心仔细地分析这些数据并与TPM规范仔细对比，这样通常就能发现失败的原因。这种类型的调试要求知道TPM2.0规范的细节——尤其是HMAC计算的细微差别。

### 最后的手段
最后一种类型的错误包括那些在调试时上述方法都不好用的错误。通常情况下这些错误在实现一个TPM新命令或者新功能的时候发生。此时没有之前可以工作的程序的调试跟踪信息可供对比，并且分析错误代码并不能定位问题。幸运的是，这种情况并不总是让人感到绝望；可以通过TPM模拟器很容易地调试这些错误。

这种类型的错误中一个常见的类型是方案错误，TPM_RC_SCHEME。这个错误表示密钥方案有问题，这个可能发生在创建密钥或者使用密钥的时候。密钥方案（机制）通常是一些结构体构成的联合，每个结构体都由多个数据域构成。许多关于怎么设置密钥方案的解释都不够明了，尤其是对于TPM2.0新手。

通常情况下，调试这些错误的最好方式是使用之前提到的调试技巧，在TPM2.0模拟器上运行代码，并单步调试。这种方式提供了一种从内部观察TPM所接收数据的方式，并了解TPM返回错误的原因。当然，这还要假设你能够访问到模拟器源码（现在这个已经不是问题了，随便google一下就好）。有了TPM的源码，你就可以单步调试模拟器并逐步找到错误的根源。

涉及的步骤如下：
1. 在windows的VS中构建并启动TPM2.0模拟器（linux+gdb也可以哦）。参考第6章中相关的内容。选择“Debug”下拉菜单，选择“Start Debugging”来以调试模式启动模拟器。

2. 将失败的程序转到模拟器上运行。最简单的方式是使用SAPI创建一个子程序，然后将子程序添加到SAPI测试程序列表中。这样一来，因为SAPI默认会使用模拟器来执行命令，所以你就不用额外开发TPM2.0的驱动来与模拟器通信，或者处理模拟器相关的平台命令，比如开启模拟器，设置Locality等等。同样还可以免费使用TAB和RM。如果不这样做，那你就得必须得自己完成这些工作。
3. 在你选择的调试器中启动运行失败的程序，单步运行到失败的命令，然后停止。这可以通过单步运行和断点来实现。
4. 在VS的模拟器运行实例中选择“Debug”下拉菜单中的“Break All”。
5. 在模拟器中设置一个你一定会运行到的断点。如果你对模拟器不是很熟，那就在TPMCmdp.c文件的_rpc_Send_Command函数的位置设置断点。
6. 选择Debug下拉菜单中的Continue再次启动模拟器。
7. 在测试程序的调试器中执行合适的命令来让程序之前设置的断点位置继续执行。
8. 模拟器会在你刚刚设置的断点处停下。从这里开始你就可以调试模拟器内部的子程序，并且最终找到TPM出错的原因。

## 常见的问题

## 高层应用软件的调试
### 调使过程
### 典型的问题
#### 授权
#### 被禁用的函数
#### 缺失对象
#### 错误的类型
#### 错误的大小
#### Policy
## 总结
