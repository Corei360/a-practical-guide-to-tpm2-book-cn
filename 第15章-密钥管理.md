# 密钥管理
使用TPM设计一个密钥管理系统时需要考虑很多事情。如果密钥用于重要的操作，比如加密或者身份认证，使用一个提供标准方法来管理密钥的架构很重要，同时这个架构还要考虑到硬件损坏的情况。这样一个密钥管理架构必须能够处理密钥生成，密钥分发，密钥备份，密钥销毁。TPM的从架构设计上一直注意这些功能。这一章描述了各种各样选项，它们用于一个密钥生命周期的各个步骤中。

## 密钥生成
当我们生成一个密钥时，需要考虑的最重要的是密钥是否真得是随机产生的。如果选择了一个比较差的随机数发生器，那么生成的密钥就会不安全。其次就是要考虑保证密钥信息的机密性。TPM被设计成可以免受软件攻击。设备厂商可以选择保护硬件，但是这不是设计规范要求的。但是，TPM的设计允许密钥的分离创建，这是指用于创建密钥的熵在TPM内部和外部都有存储，这样一来，当不使用TPM时，即使有人可以物理上接触到TPM，密钥也是安全的。

密钥在TPM中有三种存在形式。密钥可以由一个种子生成，由TPM的随机数发生器生成，或者被导入到TPM中。主密钥是通过TPM中的种子生成的。用于生成EK的种子与背书密钥组织架构有关，并且终端用户不太可能去修改它。

另一方面，与存储密钥组织架构相关的种子子在TPM收到TPM_Clear命令时就会改变。这个操作可以由使用平台组织架构的BIOS执行，或者由终端用户使用字典攻击复位口令来实现。

第10章我们已经说明，主密钥使用TIPS认可的KDF生成，KDF会将主种子和密钥模板组合起来做哈希。密钥生成的模板被分为两部分。第一部分是对密钥类型的描述——是否是一个签名密钥，具体的算法和密钥大小，等等。另外一部分描述的是密钥生成命令用于生成密钥的熵值从哪里来。大多数情况下，第二部分被设置成全0（TCG基础设施工作组公布的EK模板中有）。但是，如果用户不相信TPM内部的熵发生器，他们可以使用这个功能将密钥的熵分开，也就是密钥生成分割。

密钥分割是一个密码学构造，它包含两部分熵——每一部分都有与最终密钥相同的熵值——用于生成密钥。这两个中的任何单独一个都不能提供哪怕是一个比特的最终密钥的熵——所以这两者都是必需的。这样一来，一个可以独立于TPM存储，另外一个则存储在TPM中。

对于一个主密钥来说，一部分分割值是密钥对应组织架构的种子，这存在于TPM中。另外一部分存储在TPM之外的密钥模板中，当不使用时它可以被存储在安全的地方（比方说存储在智能卡中）。

主存储密钥有一个与之关联的对称密钥，它和主存储密钥一起生成。主密钥同样由主种子和外部引进的熵派生而来。只要与组织架构相关的种子没有变化，使用相同的密钥模板总会产生相同的主秒哟和相关的对称密钥。因为这两种密钥都使用密钥模板，如果熵由模板提供，那模板中的熵也就是一部分分割的熵。

为什么会有人分割一个密钥呢？主要的原因通常是用户担心有人可能会拿到这两部分分割密钥的一个。他们同时也担心TPM的种子在灌进TPM设备时，有人可能会保留一个副本，或者他们还会担心有人会分解TPM，就像多年前有人对英飞凌的TPM1.2芯片做的一样。这些攻击大多数是幻想狂想到的——在仅仅破坏几个TPM之后，对英飞凌芯片的攻击就成功了，并且花费超过20万美元。但是，要知道的是，安全领域的人往往都倾向于是幻想狂。

生成主密钥可能会花费相对较长的时间（如果密钥是RSA密钥），或者是几乎瞬间完成（如果是ECC密钥）。如果密钥生成需要很长时间，用户可能会决定将密钥存储在TPM的持续性内存中，这是通过TPM2_EvictControl命令来实现的，这个命令要求相关的组织架构授权。在这种情况下，密钥就会被分配一个持续性handle，并且重新上电不会影响这个密钥的存在。这个密钥可以使用相同的命令被擦出。用户可以根据所担心攻击的不同，决定是否让密钥变成持续性的密钥。

如果一个用户担心TPM的种子可能已经不安全了，那他们就会担心主密钥也不安全了。如果主密钥不安全了，所有存储在这个主密钥之下的密钥都不安全。在这种情况下，用户可以通过模板使用密钥分割来引入他们自己的熵，并且让密钥变成持续性的密钥，然后将密钥的模板委托给攻击者访问不到的地方。这样就阻止了知道TPM种子的攻击者拿到主密钥秘密信息（没有另外一部分熵）。

除此之外的另一种选择是，一个主密钥只能被用于创建另外一个存储子密钥。这个存储密钥被加载到TPM中的主密钥下。然后被转变成持续性密钥。这个密钥和TPM1.2的SRK类似。这个密钥是由TPM的随机数发生器生成，而不是种子。但是，因为它会以加密的形式短暂地出现在TPM以外的地方，在它被重新 加载到TPM以前，如果主密钥被攻破还是会有被攻击的风险。

如果用户担心TPM会遭受物理攻击，他们应该选择在密钥模板中加入第二部分的熵，也就是种子的生成来源。并且由种子生成主密钥以后不要将主密钥配置成持续性密钥。（如果主密钥被存储在TPM中，那么一个物理攻击可能会恢复它。）这种应用场景下，每次TPM重新上电以后，所有主密钥的踪迹都会消失。当然这会很难管理，因为密钥的模板必须保持机密性（很有可能在USB密钥中），并且独立于TPM，然后在每次TPM重新生成密钥时再导出到TPM中。

类似的，对于一个彻底的幻想狂来说，他不仅担心TPM的种子并且还不相信TPM的随机数发生器，一个外部密钥可以通过可信的熵源生成，然后被加密从而被导入到TPM的一个主密钥（或者是任何其他存储密钥）中并且被配置成持续性密钥；然后将主密钥擦除。如果这个用户还担心他们的系统被窃并将TPM解体然后恢复秘密信息，那他们不应该将密钥配置成持续性的，而是再每次TPM重新上电以后重新做以上复杂的工作。

```
应用案例：为不同的用户创建不同的SRK

如果一个系统有几个用户，他们可能想要完全不同的几组密钥。如果有这样的需求，他们可能需要全部生成自己的SRK（独立的限制性存储密钥）。如果他们再各自的密钥模板中使用不同的用于产生主种子的熵，那这就很容易实现。为了确保每个用户都生成不同的密钥，用于生成密钥的模板必须是明显不同的。比如说，他们可以使用用户秘密信息的哈希作为密钥模板的熵值。但是，不同的用户还是有可能选择相同的用户秘密信息（就跟两个完全不相干的人完全有可能设置相同的登陆密码一样）。或许让TPM使用它的硬件随机数发生器来为每个用户创建SRK更好。

```

```
拇指规则

只有三种原因让密钥变成持续性密钥。密钥是RSA密钥，所以重新生成可能会花费不合理的很长时间；密钥的生成可能使用了密钥模板中的熵，但是这个熵并不总是可用的，或许是TPM外部没有足够的持续性空间来存储密钥模板。如果TPM是用于资源受限的环境中，那有可能是第二种情况，比方说再启动过程中。在其他情况下，密钥应在在必要的时候重新生成。这与TPM1.2的设计不同，因为在TPM2.0的设计中，密钥加载使用对称密钥解密，因此这个过程会很快。
```

### 模板
有标准的秘钥模板用于创建秘钥，通常情况下使用这些模板比自己创建模板更合理。因为模板会使用强度匹配的算法。在选择对称秘钥的时候你可能会使用强度不匹配的算法。因为TPM2.0使用对称秘钥加载其他秘钥，而不是像TPM1.2中一样使用非对称秘钥。因此，我们可以设计一套系统，系统使用比用于主秘钥的非对称秘钥强度更高的对称秘钥。一旦实现了这样的系统，由TPM产生的秘钥就不会面临非对称秘钥或者算法强度弱的风险。

## 密钥树：将密钥保存在具有相同算法的密钥树中
尽管从技术上来说，可以混用不同的算法——使用一种算法创建一个秘钥，然后用一个不同算法的秘钥保护这个秘钥——这是一个不好的习惯（首先，已经看到了，TSS的FAPI就不允许这样做）。这样做有问题的原因是，一组秘钥的整体强度是由其中强度最弱的秘钥决定的。这样就意味着，不但不应该混用算法，而且秘钥链（就是一个秘钥加密后面的秘钥，这样组成的链式结构）也应该尽量短。如果秘钥链中的任何一个秘钥被破坏了，那所有在这个秘钥后面的秘钥也都被破坏了。所以在面对暴力攻击时，一个由四个秘钥组成的秘钥链的强度是一个单独秘钥的四分之一。（当然了，如果使用的秘钥强度合理，这个4就不重要了。）

你想要秘钥链变长的原因可能是管理性。一个用户可能想要将他所有的秘钥或者是一部分秘钥从一台机器复制到另外一台机器上，或者将将秘钥复制到其他的系统上。为了操作简单，用户更愿意使用另外系统上的公钥仅仅加密一个秘钥——就是秘钥树最顶端的秘钥，然后将加密的秘钥复制到其他系统上的合适位置。

你可能想要将企业秘钥与个人秘钥分开，以及将企业中不同部门的秘钥分开，如图15-1所示。尽管如此，这个秘钥树的深度还是越浅越好。

图 15-1 秘钥树示例

## 密钥复制
在图15-1的密钥树中，有可能被复制的密钥是个人密钥，企业密钥，金融密钥（个人或者企业），娱乐密钥，HR密钥。为了让密钥可以被复制，在创建密钥时就需要将它们配置成可复制的，并且密钥还需要有一个需要包含TPM2_PolicyCommandCode命令的Policy，TPM2_PolicyCommandCode指定的命令为TPM2_Duplicate。在大多数情况下，一个用户会创建两种复制Policy——一种用于个人密钥，另外一种用于商业密钥——并将它们分别与一个个人可复制密钥（Personal Duplicable Key）和一个用于商业的可复制密钥（Business Duplicable Key）关联起来。

如果我们不想让一个密钥被复制，可以设置属性为fixedParent。如果一个密钥想独立于它的父密钥SDK或者UDK被复制，那么这个密钥本身也必须有一个可以允许复制的Policy。

在TPM1.2中，不太可能创建一个只能复制到一部分指定的新密钥下的密钥。在TPM2.0中，使用TPM2_DuplicationSelect就可以达到这个目的。这个密令允许你精确地指定密钥将被复制到哪一个父密钥下。这个密令主要与PolicyAuthorize结合使用。通过PolicyAuthorize操作，一个IT组织可以修改用于备份的复制密钥（意思是说，这个秘钥可以作为另一个秘钥的复制操作的目的地）。如果IT组织在一个指定的服务器上备份了密钥，但是服务器坏掉了，IT可以通过TPM2_DuplicationSelect命令选择一个新的服务器，然后向员工发送一个签名过的Policy，这个Policy可以允许他们将自己的秘钥备份到新的服务器上。这样一来，通过更换新的备份服务器来避免员工将他们的秘钥备份到个人电脑上（这样可能就不安全了）。

因为TPM2_Duplicate和TPM2_DuplicationSelect命令不能够使用口令或者HMAC授权，所以为了复制一个秘钥，你必须首先启动一个Policy会话，然后满足包含TPM2_PolicyCommandCode命令的Policy分支，这个分支又与TPM2_Duplicate或者TPM2_DuplicationSelect相关联。然后就可以执行合适的命令将秘钥复制到新的父秘钥下。

```
应用案例：将一组服务器看成一个服务器

在这个案例中，一组SSL服务器中的机器可以作为另外一台机器故障转移的对象或者用于负载均衡。公司不想让用户知道他们正在连接哪一台服务器——实际上用户也不关心这个。因此公司需要在这些服务器上部署相同的密钥用于网页服务。（这也就意味着公司只能为这个密钥准备一个证书，而不是每台服务器一个。）

公司会创建一个可复制的密钥，密钥使用包含PolicyAuthorize命令的Policy。然后使用与PolicyAuthorize命令相关的私钥签名几个TPM2_DuplicationSelect命令，不同的服务器对应一个签名。一个用户认证这个密钥，然后在每一台服务器上复制一份证书，并最终使用TPM2_Import命令将密钥导入到其他的服务器上。这时候，所有的服务器对于用户来说都是一样的。

操作步骤：

1. 使用TPM2_PolicyAuthorize命令，一个企业签名密钥A，以及SSL的policyRef创建一个Policy，我们称为P。
2. 使用Policy P在初始的SSL服务器上创建一个可复制密钥B。
3. 在所有其他的SSL服务器上使用TPM2_Create命令创建限制性存储密钥SRK(i)。
4. 使用公司的私钥A签名TPM2_PolicyDuplicateSelect，并指定SRK(i, Public)作为秘钥复制的目的地。针对每个SRK做一次这个操作。
5. 在初始的SSL服务器上使用TPM2_VerifySignature命令针对每个签名的Policy生成相应的Ticket。这写Ticket使得签名过的Policy用于秘钥复制。
6. 在初始的SSL服务器上针对每一个Policy，通过以下的步骤为其他的服务器创建可复制的秘钥：
  1. 使用TPM2_Load命令加载公司的签名秘钥A的公钥。
  2. 使用TPM2_LoadExternal加载SRK(i, Public)。
  3. 使用TPM2_StartAuthSession命令启动一个Policy会话。
  4. 执行TPM2_PolicyDuplicateSelect，并选则SRK(i, Public)作为秘钥复制的目的地。
  5. 执行TPM2_PolicyAuthorize，传递Policy，SSL的policyRef，以及SRK(i)对应的Ticket。
  6. 执行TPM2_Duplicate命令，传递已加载的SRK(i, Public)，以及新创建的公司签名秘钥B的Handle。
  7. TPM2_Duplicate命令的结果就是加密过的公司签名秘钥B。将它发送到SRK(i)对应的服务器上。
  8. 在包含SRK(i)的服务器上将复制的秘钥B Import到自己的TPM中。
7. 将公司签名秘钥B的证书复制到各个服务器上。

此时，所有服务器上的秘钥B都是相同的，它可以用于SSL认证和通信。
```
## 密钥分发
在某些情况下，一些密钥需要在系统初始配置很久之后分发出去。这时，系统能够安全的分发密钥就显得很重要了。TPM的设计可以让密钥分发变得简单。当每个系统在初始配置时，系统会产生一个不可复制的存储秘钥，中央管理系统会记录这个秘钥以及秘钥所在系统的名称（或者是系统的序列号）。Active Directory或者LDAP数据库可以做这件事情。另外，在本地平台初始配置时，会将中央管理系统中一个签名私钥对应的公钥备份到平台上。后续，如果中央管理系统想要分发一个HMAC秘钥到本地平台时，会执行以下步骤：
1. 中央管理系统的IT部门使用TPM2_GetRandom创建一个HMAC秘钥。
2. 中央管理系统使用目标系统的存储公钥加密上述的HMAC秘钥。
3. 中央管理系统的IT部分使用自己的签名私钥对加密的HMAC签名。这就让本地系统可以确认它接收到的内容是经过授权的。
4. 加密的HMAC秘钥和相应的签名被发送到本地系统。
5. 本地系统使用初始配置时备份的中央系统的签名秘钥的公钥验证签名。（如果你愿意，可以通过TPM2_LoadExternal加载公钥，然后通过TPM2_VerifySignature来验证签名。）
6. 本地系统使用TPM2_Import命令将加密的HMAC秘钥导入到TPM中，然后得到一个可以加载的，包含HMAC秘钥的数据块。
7. 当用户需要使用HMAC秘钥时，本地系统使用TPM_Load命令加载这个HAMC秘钥，然后就可以正常使用来。此时，一个本地系统就从中央管理系统得到一个HMAC秘钥，并且这个秘钥全程没有在本地系统的内存中以明文的方式出现过。

## 密钥激活
## 密钥销毁
## 综合实例
### 示例1：简单的密钥管理
### 示例2：一个公司的IT组织，使用使能TPM2.0的Windows系统
## 总结
