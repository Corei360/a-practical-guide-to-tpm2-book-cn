# 扩展的授权方式
TPM2.0已经统一了所有由TPM控制的实体的授权方式。前面的章节已经讨论了口令和HMAC授权需要使用的授权数据。这一章将详细讨论TPM的一个新型的最强大的授权方式，开始我们将说明为什么在TPM中增加这种授权方式，然后我们将层层揭开这种授权方式的多层面纱。

这种新的授权方式有许多功能。总结来说就是，如果一个用户想限制一个实体只能在某些特定情况下才能被使用，使用这种方式就有可能实现。所有针对这个实体使用的限制的总和就叫做一个policy。扩展的授权（EA）Policy可以迅速变得复杂。因此，这一章的描述是渐进式的，最开始先介绍一个非常简单的Policy，然后逐步地增加难度。这个过程是通过探究如何实现以下功能来完成的：
* 简单断言。
* 基于命令的断言。
* 多因素授权。
* 多用户/组合授权。
* 可以在中途修改的灵活Policy。

纵观本章内容，你可以看到在大多数情况下会用到的实用Policy的例子。最后我们会发现创建Policy与使用Policy不同，所以你会了解到一个用户怎样满足一个Policy；此时你也就会明白为什么Policy是安全的。

最后，我们会介绍一些用于解决特殊问题的Policy。这一节可能会激发你的创造性——你将意识到有比你想象中更多的方式来使用Policy。

首先，我们通过比较EA Policy和使用口令授权的异同来开始本章的学习。

## Policy和口令
所有TPM的实体都可以通过两种基本的方式授权。第一种基于创建实体时指定的口令。另外一种基于创建实体时指定的Policy。一个Policy几乎可以包含任何你能想到的授权方式。一些实体是由TPM本身来创建的（比如组织架构和字典攻击复位的handle），因此它们对于用于来说具有默认的口令和Policy。这些实体的名称是固定的，这些实体的名称不依赖授权Policy。因此实体的Policy是可以改变的。

所有其他的实体——NVRAM索引和密钥——的名称的计算都会包含实体被创建时指定的Policy。这样的结果就是，尽管实体的口令可以改变，但是Policy是不能变的。后面你将会看到，一些Policy可以设置成灵活的Policy，这样以来就可以实现policy的灵活管理而不管Policy本身不可变的特性。

任何通过口令可以做的事情都可以通过Policy来做，但是反过来就不可以。有一些事情（比如复制密钥）只能通过Policy来授权操作。（但是，为了让事情变得更复杂，你仍然可以使用一个口令来授权复制密钥操作，这是通过Policy来指定的（TPM2_PolicyAuthValue））

一个Policy可以被很精细的设置——机会任何事情都是可能的，policy可以被设置成从一个永远不会被满足的NULL Policy到设置成不同命令或者用户有不同授权要求的policy。因此EA可以解决许多应用程序开发者需要处理的问题。

## 为什么使用扩展的授权方式？
TPM中EA的设计初衷是为了解决TPM实体授权管理的基本问题。让所有的TPM实体都以同样的方式授权，这可以让我们更容易地学习如何使用TPM。同时，EA也允许用户定义授权Policy来解决如下的问题：
* 允许多种变化的授权（口令，生物信息等等）。
* 允许多因素的授权方式（要求多一种的授权类型）。
* 允许在不使用TPM的情况下创建Policy。Policy本身不包含任何秘密信息，所以可以完全由软件来创建。但是这并不等于满足一个Policy不需要秘密信息。
* 允许认证与一个实体相关联的Policy。用户应该能够知道使用一个实体时哪些授权是必须的。
* 允许多个用户或者角色来满足一个Policy。
* 允许限制某一个对象的特定角色的动作或者使用用户。
* 修正了PCR脆弱的问题。在TPM1.2中，如果一个实体被“锁定”到包含特定配置的一组PCR中，一旦配置不得不变化，那这个实体就不能使用了。

### 授权的多个变种
现在，许多不同种类的技术和设备被用于授权。口令是最古老授权方式（或许也是强度最弱的）。生物信息比如说指纹，虹膜扫描，脸部识别，手写签名，甚至是心率都被用于授权。数字签名和HMAC是用于密钥的密码学授权方式。银行的时钟把一天中的时间作为授权信息，它不允许在交易时间之外打开金库。

TPM被设计成几乎可以使用任何能想到的授权方式，尽管许多情况下需要额外的硬件。一个Policy可以由一种单独的授权方式或者多种授权变种组成。

### 多元素认证
多因素认证是安全的多种表现形式之一，并且它在当今很流行。为了授权执行一个命令，需要执行多种授权方式。这些授权可以有很多种形式——智能卡，口令，生物信息，等等。基本的原理就是攻击多种授权比只攻击一种要难。不同类型的授权有不同的优缺点。比如说，口令可以很容易地实现远程提供——但是指纹就没那么容易，尤其实在设计正确的情况下。

TPM2.0的设计允许多种不同的授权，并且提供机制来支持更多的外部设备。每一种可以用于认证的机制被叫做断言。断言包含以下内容：
* 口令。
* HMAC。
* 提供数字签名的智能卡。
* 物理存在/接触（Physical presence）。
* 机器的状态（PCR）。
* TPM的状态（计数器，时间）。
* 外部设备的状态（指纹读卡器，GPS等等）。

一个Policy可以要求任意数量的断言为真来满足它。TPM种EA背后的创新是它将包含多种断言的复杂Policy表现为一个哈希值。

## 扩展的授权方式是怎样工作的？
一个Policy就是一个可以表示一组授权的哈希值，这些授权组合起来可以描述如何满足一个Policy。当一个实体（比如说一个密钥）被创建的时候，它可能和一个Policy关联。为了使用这个实体，用户需要向TPM证明这个Policy已经被满足了。

这需要以下三个步骤：
1. 创建一个Policy会话。Policy会话被启动时，TPM会为这个会话创建一个会话Policy缓冲区。（缓冲区的大小与创建会话时选择的哈希算法相匹配，并且初始化为全0）
2. 用于通过TPM2_PolicyXXX命令向TPM会话提供一个或者多个授权信息。这些操作会改变会话Policy缓冲区的值。这些操作还可能会设置会话的一些标志位，这些标志位用于指示TPM在执行命令时必须执行的一些检查。
3. 当一个命令使用一个实体时，TPM会比较会话Policy缓冲区与实体的授权Policy。如果这两者不同，命令就不会被执行。（此时，与Policy授权相关的会话标志位也会被检查。如果它们也不满足，这个命令也不会被执行）

Policy不包含任何秘密信息。也就是说，所有的Policy都可以使用纯软件的方式在TPM之外创建。但是，为了使用它们，TPM必须能够重新生成这些Policy（以会话的Policy摘要的形式）。因为TPM有产生Policy的能力，所以允许用户使用TPM的这个功能来产生Policy就比较合理了。这是通过Trial Policy来实现的。一个Trial Policy不能用于满足一个Policy，但是它可以用于计算一个Policy的哈希值。

用于满足授权Policy的Policy会话在某种程度上要比用于创建Policy的Trial Policy会话复杂。一些Policy命令会立即检查一些断言并更新存储在会话中的Policy缓冲区。另外一些命令则会设置标志或者设置会话中的变量，当命令真正被执行时这些标志和变量会被检查。表14-1什么Policy命令会有这样的检查。

表14-1 会设置标志位的Policy命令

|命令|设置标志位或者变量用于指示TPM在执行命令时检查它们|
| --- | --- |
|TPM_PolicyAuthorize|否 |
|TPM_PolicyAuthValue|是——设置标志位指示命令执行时需要使用HMAC会话|
|TPM_PolicyCommandCode|是——检查是否是一个特定的命令在执行|
|TPM_PolicyCounterTimer|是——执行针对TPMS_TIME_INFO的逻辑检查|
|TPM_PolicyCpHash|是——检查命令和参数是特定的值|
|TPM_PolicyLocality|是——检查命令是通过某一个特定的Locality来执行的|
|TPM_PolicyNameHash|是——在命令执行时检查对象的身份，也就是名称是否匹配|
|TPM_PolicyOR|否|
|TPM_PolicyTicket|否|
|TPM_PolicyPCR|是——在命令执行时检查PCR的值没有变化|
|TPM_PolicySigned|否|
|TPM_PolicySecret|否|
|TPM_PolicyNV|否|
|TPM_PolicyDuplicationSelect|是——决定一个密钥被复制到一个特定的密钥对象下面|
|TPM_PolicyPassword|是——命令执行时检查口令|

## 创建Policy
我们可以创建非常复杂的Policy，但是实际应用中不大可能会用到它们。为了解释Policy的创建，这一章人为地对不同类型的Policy进行分类，具体分来如下：
* 简单断言Policy：使用一个认证方式创建Policy。比如口令，智能卡，生物信息，时间等等。
* 多断言Policy：将几种断言结合起来，比如同时要求生物信息和口令；或者智能卡和PIN码；或者口令，智能卡，生物信息，以及GPS位置信息。这样的Policy等价于使用AND操作将多种断言组合。
* 混合Policy：这里引入逻辑操作OR，比如说”Bill可以使用一个智能卡授权或者Sally可以使用口令授权“。混合Policy可以由任何其他种类的Policy组成。
* 灵活多变的Policy：使用通配符或者占位符，具体的授权内容以后定义。一个Policy的特定部分可以被其他允许的Policy替换。这看起来像是一个简单的断言，但是实际上是任意的（简单或者复杂的）Policy都可以替换它。

前面已经提到，一个Policy是一个哈希值，这个哈希值表现为满足这个Policy的方式。一个Policy启动时表现为一个缓冲区，缓冲区大小为相关实体的哈希算法对应的哈希长度，缓冲区会被初始化成全0。当部分Policy被满足时，这个缓冲区会被扩展能够表示这一事件（具体来说就是Policy相关命令的执行）的值。扩展缓冲区的操作就是连接缓冲区当前值和新的数据，然后使用指定的哈希算法对上述的连接结果做哈希，将缓冲区更新成这个哈希值。下面让我们使用最简单的Policy来展示这个过程：最简单的Policy就是指哪些仅仅需要一种授权认证方式的Policy。

### 简单的断言policy
一个简单的EA Policy：也就是只包含一种认证方式的简单断言Policy，它可以是如下形式的一种：
* 口令或者HMAC（需要向TPM证明，用户知道对象的口令的Policy）。
* 数字签名（智能卡）。
* 外部设备的认证（一个生物信息读卡器用于验证特定的用户身份，或者一个用于证明机器在特定位置的GPS设备）。
* 物理存在（是一个类似开关的指示，它可以证明一个用户可以在物理上接触到TPM。尽管这个在规范中有定义，但是很可能不会实现，所以我们后续会忽略这个功能）。
* PCR（TPM宿主设备的状态）。
* Locality（表示发出TPM命令的软件所在的系统特权级别）。
* TPM内部状态（计数器值，定时器的值等等）。

可以使用TPM创建一个简单断言Policy，步骤如下：
1. 建一个Trial Policy会话。仅仅需要执行下面的命令：

TPM2_StartAuthSession

需要传递一个参数TPM_SE_TRIAL来告知TPM启动一个Trial会话，还需要一个哈希算法的参数用于计算Policy的值。这个命令会返回（还有其他的信息）Trial会话的handle。这里我们成为myTrialSessionHandle。

2. 执行TPM2的Policy命令（后面很快会介绍）。
3. 通过执行下面的命令要求TPM提供Policy的值

TPM2_PolicyGetDigest

这个命令需要传递Trial会话的Handle：myTrialSessionHandle。

4. 通过执行如下命令来结束会话（或者如果你还想再次使用这个会话就复位这个会话）

TPM2_FlushContext

这个命令同样需要传递Trial会话的Handle：myTrialSessionHandle。

因为对于简单的断言Policy来说步骤1，3，4是通用的，后面将不再重复；下面我们将介绍第2步中涉及到的每个命令。

#### 对象的口令（明文或者HMAC）
#### 另外一个对象的口令
#### 数字签名（比如智能卡）
#### PCR：机器的状态
#### 命令的Locality
#### TPM内部的状态（启动计数器和定时器）
#### NV内存区域的值
#### 外部设备的状体（GPS，指纹读卡器，以及其他）
#### 灵活的Policy（通用型）
#### 示例1：智能卡和口令
#### 示例2：一个密钥的policy只能使用一个口令来授权签名操作
#### 示例3：一个PC状态，一个口令，一个指纹
#### 示例4：用于一个启动周期的Policy
#### 示例5：灵活的PCR的Policy
#### 示例6：用于一组许可的Policy
#### 示例7：用于NV内存1-100的Policy
## 基于命令的断言
## 多元素认证
## 混合Policy：在一个Policy中使用逻辑OR
### 生成一个混合Policy
### 示例：一个用于工作或者家庭电脑的Policy
## 创建Policy时需要考虑的因素
### 终端用户角色
### 管理员角色
### 候补角色
### 办公室角色
### 家庭角色
## 使用Policy授权一个命令
### 启动Policy
### 满足Policy需要的条件
#### 简单断言和多因素断言
### 如果是混合Policy
### 如果是灵活的Policy（通配型）
#### 满足被允许的Policy
#### 改变灵活Policy中被允许的Policy
## 认证过的Policy
## 总结
