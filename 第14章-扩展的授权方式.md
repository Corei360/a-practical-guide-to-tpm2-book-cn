# 扩展的授权方式
TPM2.0已经统一了所有由TPM控制的实体的授权方式。前面的章节已经讨论了口令和HMAC授权需要使用的授权数据。这一章将详细讨论TPM的一个新型的最强大的授权方式，开始我们将说明为什么在TPM中增加这种授权方式，然后我们将层层揭开这种授权方式的多层面纱。

这种新的授权方式有许多功能。总结来说就是，如果一个用户想限制一个实体只能在某些特定情况下才能被使用，使用这种方式就有可能实现。所有针对这个实体使用的限制的总和就叫做一个policy。扩展的授权（EA）Policy可以迅速变得复杂。因此，这一章的描述是渐进式的，最开始先介绍一个非常简单的Policy，然后逐步地增加难度。这个过程是通过探究如何实现以下功能来完成的：
* 简单断言。
* 基于命令的断言。
* 多因素授权。
* 多用户/组合授权。
* 可以在中途修改的灵活Policy。

纵观本章内容，你可以看到在大多数情况下会用到的实用Policy的例子。最后我们会发现创建Policy与使用Policy不同，所以你会了解到一个用户怎样满足一个Policy；此时你也就会明白为什么Policy是安全的。

最后，我们会介绍一些用于解决特殊问题的Policy。这一节可能会激发你的创造性——你将意识到有比你想象中更多的方式来使用Policy。

首先，我们通过比较EA Policy和使用口令授权的异同来开始本章的学习。

## Policy和口令
所有TPM的实体都可以通过两种基本的方式授权。第一种基于创建实体时指定的口令。另外一种基于创建实体时指定的Policy。一个Policy几乎可以包含任何你能想到的授权方式。一些实体是由TPM本身来创建的（比如组织架构和字典攻击复位的handle），因此它们对于用于来说具有默认的口令和Policy。这些实体的名称是固定的，这些实体的名称不依赖授权Policy。因此实体的Policy是可以改变的。

所有其他的实体——NVRAM索引和密钥——的名称的计算都会包含实体被创建时指定的Policy。这样的结果就是，尽管实体的口令可以改变，但是Policy是不能变的。后面你将会看到，一些Policy可以设置成灵活的Policy，这样一来就可以实现policy的灵活管理而不管Policy本身不可变的特性。

任何通过口令可以做的事情都可以通过Policy来做，但是反过来就不可以。有一些事情（比如复制密钥）只能通过Policy来授权操作。（但是，为了让事情变得更复杂，你仍然可以使用一个口令来授权复制密钥操作，这是通过Policy来指定的（TPM2_PolicyAuthValue））

一个Policy可以被很精细的设置——机会任何事情都是可能的，policy可以被设置成从一个永远不会被满足的NULL Policy到设置成不同命令或者用户有不同授权要求的policy。因此EA可以解决许多应用程序开发者需要处理的问题。

## 为什么使用扩展的授权方式？
TPM中EA的设计初衷是为了解决TPM实体授权管理的基本问题。让所有的TPM实体都以同样的方式授权，这可以让我们更容易地学习如何使用TPM。同时，EA也允许用户定义授权Policy来解决如下的问题：
* 允许多种变化的授权（口令，生物信息等等）。
* 允许多因素的授权方式（要求多一种的授权类型）。
* 允许在不使用TPM的情况下创建Policy。Policy本身不包含任何秘密信息，所以可以完全由软件来创建。但是这并不等于满足一个Policy不需要秘密信息。
* 允许认证与一个实体相关联的Policy。用户应该能够知道使用一个实体时哪些授权是必须的。
* 允许多个用户或者角色来满足一个Policy。
* 允许限制某一个对象的特定角色的动作或者使用用户。
* 修正了PCR脆弱的问题。在TPM1.2中，如果一个实体被“锁定”到包含特定配置的一组PCR中，一旦配置不得不变化，那这个实体就不能使用了。

### 授权的多个变种
现在，许多不同种类的技术和设备被用于授权。口令是最古老授权方式（或许也是强度最弱的）。生物信息比如说指纹，虹膜扫描，脸部识别，手写签名，甚至是心率都被用于授权。数字签名和HMAC是用于密钥的密码学授权方式。银行的时钟把一天中的时间作为授权信息，它不允许在交易时间之外打开金库。

TPM被设计成几乎可以使用任何能想到的授权方式，尽管许多情况下需要额外的硬件。一个Policy可以由一种单独的授权方式或者多种授权变种组成。

### 多元素认证
多因素认证是安全的多种表现形式之一，并且它在当今很流行。为了授权执行一个命令，需要执行多种授权方式。这些授权可以有很多种形式——智能卡，口令，生物信息，等等。基本的原理就是攻击多种授权比只攻击一种要难。不同类型的授权有不同的优缺点。比如说，口令可以很容易地实现远程提供——但是指纹就没那么容易，尤其实在设计正确的情况下。

TPM2.0的设计允许多种不同的授权，并且提供机制来支持更多的外部设备。每一种可以用于认证的机制被叫做断言。断言包含以下内容：
* 口令。
* HMAC。
* 提供数字签名的智能卡。
* 物理存在/接触（Physical presence）。
* 机器的状态（PCR）。
* TPM的状态（计数器，时间）。
* 外部设备的状态（指纹读卡器，GPS等等）。

一个Policy可以要求任意数量的断言为真来满足它。TPM种EA背后的创新是它将包含多种断言的复杂Policy表现为一个哈希值。

## 扩展的授权方式是怎样工作的？
一个Policy就是一个可以表示一组授权的哈希值，这些授权组合起来可以描述如何满足一个Policy。当一个实体（比如说一个密钥）被创建的时候，它可能和一个Policy关联。为了使用这个实体，用户需要向TPM证明这个Policy已经被满足了。

这需要以下三个步骤：
1. 创建一个Policy会话。Policy会话被启动时，TPM会为这个会话创建一个会话Policy缓冲区。（缓冲区的大小与创建会话时选择的哈希算法相匹配，并且初始化为全0）
2. 用于通过TPM2_PolicyXXX命令向TPM会话提供一个或者多个授权信息。这些操作会改变会话Policy缓冲区的值。这些操作还可能会设置会话的一些标志位，这些标志位用于指示TPM在执行命令时必须执行的一些检查。
3. 当一个命令使用一个实体时，TPM会比较会话Policy缓冲区与实体的授权Policy。如果这两者不同，命令就不会被执行。（此时，与Policy授权相关的会话标志位也会被检查。如果它们也不满足，这个命令也不会被执行）

Policy不包含任何秘密信息。也就是说，所有的Policy都可以使用纯软件的方式在TPM之外创建。但是，为了使用它们，TPM必须能够重新生成这些Policy（以会话的Policy摘要的形式）。因为TPM有产生Policy的能力，所以允许用户使用TPM的这个功能来产生Policy就比较合理了。这是通过Trial Policy来实现的。一个Trial Policy不能用于满足一个Policy，但是它可以用于计算一个Policy的哈希值。

用于满足授权Policy的Policy会话在某种程度上要比用于创建Policy的Trial Policy会话复杂。一些Policy命令会立即检查一些断言并更新存储在会话中的Policy缓冲区。另外一些命令则会设置标志或者设置会话中的变量，当命令真正被执行时这些标志和变量会被检查。表14-1什么Policy命令会有这样的检查。

表14-1 会设置标志位的Policy命令

|命令|设置标志位或者变量用于指示TPM在执行命令时检查它们|
| --- | --- |
|TPM_PolicyAuthorize|否 |
|TPM_PolicyAuthValue|是——设置标志位指示命令执行时需要使用HMAC会话|
|TPM_PolicyCommandCode|是——检查是否是一个特定的命令在执行|
|TPM_PolicyCounterTimer|是——执行针对TPMS_TIME_INFO的逻辑检查|
|TPM_PolicyCpHash|是——检查命令和参数是特定的值|
|TPM_PolicyLocality|是——检查命令是通过某一个特定的Locality来执行的|
|TPM_PolicyNameHash|是——在命令执行时检查对象的身份，也就是名称是否匹配|
|TPM_PolicyOR|否|
|TPM_PolicyTicket|否|
|TPM_PolicyPCR|是——在命令执行时检查PCR的值没有变化|
|TPM_PolicySigned|否|
|TPM_PolicySecret|否|
|TPM_PolicyNV|否|
|TPM_PolicyDuplicationSelect|是——决定一个密钥被复制到一个特定的密钥对象下面|
|TPM_PolicyPassword|是——命令执行时检查口令|

## 创建Policy
我们可以创建非常复杂的Policy，但是实际应用中不大可能会用到它们。为了解释Policy的创建，这一章人为地对不同类型的Policy进行分类，具体分来如下：
* 简单断言Policy：使用一个认证方式创建Policy。比如口令，智能卡，生物信息，时间等等。
* 多断言Policy：将几种断言结合起来，比如同时要求生物信息和口令；或者智能卡和PIN码；或者口令，智能卡，生物信息，以及GPS位置信息。这样的Policy等价于使用AND操作将多种断言组合。
* 混合Policy：这里引入逻辑操作OR，比如说”Bill可以使用一个智能卡授权或者Sally可以使用口令授权“。混合Policy可以由任何其他种类的Policy组成。
* 灵活多变的Policy：使用通配符或者占位符，具体的授权内容以后定义。一个Policy的特定部分可以被其他允许的Policy替换。这看起来像是一个简单的断言，但是实际上是任意的（简单或者复杂的）Policy都可以替换它。

前面已经提到，一个Policy是一个哈希值，这个哈希值表现为满足这个Policy的方式。一个Policy启动时表现为一个缓冲区，缓冲区大小为相关实体的哈希算法对应的哈希长度，缓冲区会被初始化成全0。当部分Policy被满足时，这个缓冲区会被扩展能够表示这一事件（具体来说就是Policy相关命令的执行）的值。扩展缓冲区的操作就是连接缓冲区当前值和新的数据，然后使用指定的哈希算法对上述的连接结果做哈希，将缓冲区更新成这个哈希值。下面让我们使用最简单的Policy来展示这个过程：最简单的Policy就是指哪些仅仅需要一种授权认证方式的Policy。

### 简单的断言policy
一个简单的EA Policy：也就是只包含一种认证方式的简单断言Policy，它可以是如下形式的一种：
* 口令或者HMAC（需要向TPM证明，用户知道对象的口令的Policy）。
* 数字签名（智能卡）。
* 外部设备的认证（一个生物信息读卡器用于验证特定的用户身份，或者一个用于证明机器在特定位置的GPS设备）。
* 物理存在（是一个类似开关的指示，它可以证明一个用户可以在物理上接触到TPM。尽管这个在规范中有定义，但是很可能不会实现，所以我们后续会忽略这个功能）。
* PCR（TPM宿主设备的状态）。
* Locality（表示发出TPM命令的软件所在的系统特权级别）。
* TPM内部状态（计数器值，定时器的值等等）。

可以使用TPM创建一个简单断言Policy，步骤如下：
1. 建一个Trial Policy会话。仅仅需要执行下面的命令：

TPM2_StartAuthSession

需要传递一个参数TPM_SE_TRIAL来告知TPM启动一个Trial会话，还需要一个哈希算法的参数用于计算Policy的值。这个命令会返回（还有其他的信息）Trial会话的handle。这里我们成为myTrialSessionHandle。

2. 执行TPM2的Policy命令（后面很快会介绍）。
3. 通过执行下面的命令要求TPM提供Policy的值

TPM2_PolicyGetDigest

这个命令需要传递Trial会话的Handle：myTrialSessionHandle。

4. 通过执行如下命令来结束会话（或者如果你还想再次使用这个会话就复位这个会话）

TPM2_FlushContext

这个命令同样需要传递Trial会话的Handle：myTrialSessionHandle。

因为对于简单的断言Policy来说步骤1，3，4是通用的，后面将不再重复；下面我们将介绍第2步中涉及到的每个命令。

#### 对象的口令（明文或者HMAC）
口令是现在最常用的认证方式，但是它还远远谈不上安全。尽管如此，因为太多设备在使用口令了，所以TPM支持口令授权是很重要的。（TPM1.2不支持明文口令——仅支持能够证明用户知道口令的HMAC方式。TPM2.0则两种都支持。）TPM会假设当用户使用口令时，会有一个口令输入接口到TPM设备的可信通道。如果不存在这样的可信通道，TPM2.0的架构也支持使用加盐的HAMC会话来证明用户知道口令，这样口令就不用以明文的方式传送了，13章有相关的介绍。当一个对象被加载到TPM设备后，TPM知道与对象相关的口令。因此，一个Policy并不需要包含口令信息。这样一来，一个Policy就可以应用于具有不同口令的实体。

创建一个简单的断言Policy可以缩减成如下四个步骤：
1. 配置Policy缓冲区并清零，缓冲区长度设置为哈希算法的输出长度。

图14-1 初始化Policy ： 0x0000....0000

2. 将缓冲区与TPM_CC_PolicyAuthValue连接在一起。

图14-2 根据规范将缓冲区与Policy数据连接在一起：0x0000....0000TPM_CC_PolicyAuthValue

3. 根据TPM2.0规范第2部分将TPM_CC_PolicyAuthValue替换成对应的数值。

图14-3 替换TPM_CC_PolicyAuthValue：0x0000....000016B

4. 计算上述连接后数值的哈希值，然后将结果置于缓冲区中。这个最终的结果就是一个简单断言的Policy。

图14-4 计算连接值得哈希并更新到缓冲区中：0x8fcd2169ab92694................1fc7ac1eddc1fddb0e

当Policy命令被执行时，Policy会话的缓冲区将会被设置成上述过程最终的哈希值。另外，TPM的会话还会设置一个标志用于指示TPM，当一个命令使用的对象需要这个Policy授权时，用户还必须通过口令会话（默认存在的）提供对象的口令，TPM要检查这个口令是否与对象的口令匹配。

类似的情况是，当一个Policy使用HMAC断言时，会发生下面两件事情：
1. Policy的缓冲区被扩展，使用TPM_CC_PolicyAuthValue。
2. TPM的会话还会设置一个标志用于指示TPM，当一个命令使用的对象需要使用这个Policy授权时，还需要一个独立的HMAC会话。TPM会检查口令HAMC值并且与对象的授权值比较，如果匹配才会允许访问（参考第13章）。

如果你正在使用一个Trial Policy会话来创建一个Policy，需要执行TPM2_PolicyAuthValue命令并且向命令传递Trial会话的handle。

这种授权的方式意味着当你使用口令时，不论口令是以明文还是以HMAC的形式，明文口令或者HMAC形式的口令都必须与Policy会话结合起来授权对象的使用。TPM_CC_PolicyAuthValue刚刚在前面的描述中出现了两次，这不是排版错误：这个重复意味着，选择使用明文口令还是HMAC不是在Policy创建的时候决定的，而是在非Policy相关的命令执行时决定的。具体来讲，怎么样向TPM证明用户知道口令（明文还是HMAC）是用户在使用对象的时候由用户自己决定的，而不是创建Policy的时候决定（这听起来很Make Sense）。

口令并不是最安全的授权方式。一个比口令安全得多的方式是使用数字签名，通常使用智能卡来实现，比如DoD（United States Department of Defense）的CAC（Common Access Card）卡或者PIV（United States Federal Personal Identity Verification）卡。

#### 另外一个对象的口令
TPM2.0的一个一个新的（并且非常有用）断言Policy是，要求用户知道与当前被授权实体不同的实体的口令。尽管这一开始听起来很奇怪，但是因为NVRAM实体和密钥对象行为的不同，这个功能会很有用。当一个密钥对象的口令通过TPM2_ChangeAuth命令被修改时，实际上发生的事情是这个密钥被复制一份并且使用新的口令。并且并不能保证旧版本的密钥会被丢弃。因为密钥对象通常会以文件的形式存在于TPM设备之外，因此TPM也就不能保证旧版本密钥文件会被删除。但是，NV实体是完全存在于TPM中的：如果口令被修改，它就真的修改了。旧版本的实体就再也不能被使用了。

这就意味着，如果创建一个密钥的时候使用一个要求用户输入一个NV实体的口令的Policy，那就可以修改密钥Policy对应的NV的口令，同时不同担心原来的口令任然可以用于授权这个密钥。在这个案例中，修改NV的口令就有效地（“真正地”）修改了密钥的“授权口令”。因此，TPM2.0允许你使用NVRAM实体的口令来授权一个密钥的使用。

更进一步讲，这个特性也使得管理大量实体的口令成为可能。假设你创建了一个要求一个特定NV索引口令的Policy，并且将这个Policy与很多数量的密钥关联。那么你可以通过修改一个NV索引的口令有效地实现修改大量密钥的授权口令。

TPM2_PolicySecret命令需要你传递对象的名称，并且Policy会检查这个对象的口令（言外之意就是，如果你用TPM2_PolicySecret创建一个Policy，那必须同时包含TPM2_PolicyAuthValue命令）。有一点可能不是特别明显，那就是当你为一个对象创建Policy时，你不能在对象创建之前向TPM2_PolicySecret命令传递对象的名称。这是因为对象的名称本身就是依赖对象的Policy来计算的，同时一个使用TPM2_PolicySecret的Policy又依赖对象的名称，这就是一个恶性死循环。这就解释了为什么这样的Policy同时还要使用TPM2_PolicyAuthValue命令（注意，此时应该是指使用另外一个对象的口令）。因为TPM2_PolicyAuthValue提供了一种指向被授权对象的授权区域的方法。（目前这里还不是很理解，参考一下第11章中的“USE CASE: STORING A COMMON PASSWORD”，这一章结束以后再思考）

为了在Trial会话中计算Policy，你会执行TPM2_PolicySecret命令并传递Trial会话的handle，同时还有授权需要的另外一个对象（比如上述的NV实体）的handle。这个操作就会使用TPM_CC_PolicySecret||authObject->Name||policyRef来扩展Policy缓冲区。传递到命令的参数是Policy将会用到的对象的handle。前面已经提到，TPM会使用对象的名称来扩展会话的Policy缓冲区。不使用Handle就避免了修改对象handle（使用ResourceManager有可能会的，参考前面几章的相关描述）造成安全信息泄露。

技术上来说，执行TPM2_PolicySecret需要你提供一个授权会话用于对象Handle的授权（不太明白这个说法，以NV的例子来说，实际上就是提供NV的授权口令）。尽管规范上说在Trial会话中不必如此，但是大多数的实现中是需要的。因此，执行这个命令的时候你必须也得提供正确的口令或者HMAC会话。当然，如果你使用纯软件的方式来计算Policy，就不需要了。

#### 数字签名（比如智能卡）
通常来说使用私钥来授权TPM1.2的实体是不可能的。在TPM2.0中是可以的。也就是说，TPM2.0可以使用数字签名来做访问控制。当一个Policy包含这样的断言时，Policy的值会被扩展以下内容：TPM_CC_PolicySigned，SHA256(publicKey)以及一个policyRef。（一个policyRef用于精确地指定签名过的断言如何被使用。通常情况下它是一个空缓冲区，但是如果用户是在认证一个远程操作，他可能想精确地识别在授权什么动作。如果Policy中包含policyRef，授权方在授权动作时必须对这个值签名。）

用户可以在Trial会话中执行TPM2_PolicySigned命令创建上述的Policy；但是在创建Policy之前，TPM必须知道用于验证签名的公钥。因此，在此之前要将公钥加载到TPM中。一种简单的方式就是使用TPM2_LoadExternal命令将公钥TPM_RH_NULL组织架构下。当你调用TPM2_LoadExternal时，需要传递一个公钥的数据结构。

TPM2_LoadExternal命令会返回一个已加载公钥的handle，现在我们称作aPublicHandle。然后你就可以执行TPM2_PolicySigned命令，并且传递Trial会话的handle和刚刚加载的公钥handle。

满足这个Policy是一个骗局。向TPM证明用户拥有一个包含公钥对应的私钥的智能卡才是更关键的。证明的方式就是用私钥签名由TPM产生的一个nonce值。本章的最后会详细介绍。

Policy还可以要求另外一种断言：TPM所在的宿主机环境是正常的。这是通过PCR来实现的。

#### PCR：机器的状态
TPM中的PCR通常会被启动前后的软件扩展，从而用于表示当前系统运行软件的状态。在TPM1.2的设计中，只有很少一部分功能可以使用这种授权。更槽糕的是，因为使用PCR授权TPM1.2的秘钥是一种很脆弱的操作，这个限制也让PCR很难用于授权。

TPM2.0的设计允许包含特定值的PCR用于授权任何命令或者实体。Policy只需要指定被引用PCR的序号以及相应的哈希值。另外，TPM2.0包含了多种方式来处理PCR的脆弱性。重申一次，所有的Policy都由一个大小和哈希算法对应的全0缓冲区开始。为了使用PCR断言，policy会被扩展以下值：TPM_CC_PolicyPCR||PCRs selected||digest of the values to be in the PCRs selected。

如果使用一个Trial会话计算Policy，用户首先要选择期望的PCR值，并将它们存入TPML_PCR_SELECTION。然后计算这些值的哈希，将这个哈希值称为pcrDigest。然后用户执行TPM2_PolicyPCR命令，并且传递Trial会话的handle以及选择的PCR和刚刚计算出的pcrDigest。

当用户想访问被锁定到PCR的实体时，他们需要使用TPM2_PolicyPCR命令，同时传递一个PCR索引及其期望值pcrDigest的列表。TPM会计算这些PCR的哈希值并与传递的值相比较，如果匹配，TPM就会扩展Policy授权会话中Policy哈希的值：TPM_CC_PolicyPCR||PCRs selected||digest of the values currently in the PCRs selected。

这里可能会留下一个安全漏洞——万一上述的断言通过之后PCR的值发生变化怎么办？在执行TPM_PolicyPCR命令时，TPM会通过记录TPM会话状态中的PCR生成计数器来阻止这样的漏洞。当Policy会话正在用于一个命令的授权时，TPM会检查当前PCR的计数器与之前记录的值是否匹配，如果不匹配，那这个会话就不能用于授权。

作为额外的灵活特性，平台相关的规范可以指定某些PCR的值不会更新TPM内部的计数器。因此，修改这些PCR的值不会影响会话的授权功能。

#### 命令的Locality
TPM1.2版本的设计中有一个特性叫做Locality，它用于决定发送到TPM设备的命令来自于什么样的软件栈。TPM1.2中，Locality的主要用途是用于证明CPU处于一个特殊的模式中，这个特殊的模式是指进入Intel TXT或者AMD-V命令模式（这两种模式分别位于Intel和AMD的CPU中）。这些命令主要用于当机器处于不可信的系统运行状态时执行动态信任根测量（DRTM），这样一来就可以可信地报告软件的状态。

在TPM2.0中，就像PCR断言被扩展到任意的授权应用中一样，Locality也被扩展到通用的断言操作中。当Policy的一个断言使用Locality时，会话的Policy摘要会被扩展以下值：TPM_CC_PolicyLocality||locality(ies)。

如果使用Trial会话来计算Policy，需要执行TPM2_PolicyLocality命令，同时传递Trial会话的handle以及Locality数据结构（指定哪一个Locality），TPMA_Locality，TPM规范的第2部分会有这个数据结构的定义。

当需要满足一个会话的Locality断言时，用户同样需要使用TPM2_PolicyLocality命令来传递与这个会话绑定的Locality信息。此时会发生以下两件事：
1. 会话的摘要被扩展以下的值：TPM_CC_PolicyLocality||locality(ies)。
2. 一个会话的变量被设置成命令的参数Locality。

当用户使用这个会话执行命令时，TPM会比较命令数据中的Locality信息（查看以下PTP规范中的Bit Protocol）和会话之前用变量记录的Locality信息。如果不匹配，命令就不会执行。

在TPM1.2规范中，一共有5个Locality——0，1，2，3，以及4——它们分别使用一个字节中的一个比特位来表示。这种表现方式可以允许你一次选择多个Locality：比如说，0b00011101表示选择Locality0，2，3以及4。在TPM2.0规范中，可以通过PolicyOr命令来实现这样的操作（言外之意就是不允许像1.2中这样操作了呗？）；但是为了降低人们从TPM1.2到2.0迁移的认知难度，在2.0中，Locality0-4的表示方法还和以前一样。

用位域表示Locality的问题就是，一个字节可以表示的Locality数量太少了。出去已有的5个Locality，只可能再增加3个Locality，分别用5，6，和7。但是，TCG的移动和虚拟化工作组想要更多的Locality，所以高于一个字节中5位以上的值被表示成单独的Locality。最后的结果就是，2.0中的Locality由以下内容组成——0，1，2，3，4，32，33，34，...255。也就是说，为了与TPM1.2兼容，2.0扩展Locality后不能表示Locality5-31。表14-2展示了这一点，注意一下当Locality值是32时的变化。

表14-2 Locality表示方法

|Value|Binary Representation|Locality(ies) Represented|
| ---- | ---- | ---- |
|0 |0b00000000 |None |
|1 |0b00000001 |Locality 0 |
|2 |0b00000010 |Locality 1 |
|3 |0b00000011 |Localities 0,1 |
|4 |0b00000100 |Locality 2 |
|5 |0b00000101 |Localities 0,2 |
|6 |0b00000110 |Localities 1,2 |
|7 |0b00000111 |Localities 0,1,2 |
|8 |0b00001000 |Locality 3 |
|9-30 |... |... |
|31 |0b00011111 |Localities 0,1,2,3,4 |
|32 |0b00100000 |Locality 32 |
|33 |0b00100001 |Locality 33 |
|34 |0b00100010 |Locality 34 |
|35-254|... |... |
|255 |0b11111111 |Locality 255 |

Locality可以应用于很多地方。它可以用于表示创建实体的命令的来源。它们还可以用于将一些功能绑定到到特定的软件上。在1.2中，Locality会用于将CPU与复位和扩展特定的PCR绑定在一起（比如PCR17，18），这样是为了在DRTM之前将机器复位成一个已知的状态。SourceForge上的tboot软件展示了它是怎样使用Locality的；来自于CMU的Flicker使用tboot在与OS独立的内存空间内执行安全相关的操作。

因此，Locality会告诉TPM当前这个命令来自于什么软件（或者硬件）。因为TPM天生就知道命令的具体信息（这意思是说，TPM自己在解析命令的时候可以根据Bit Protocol解析出Locality等信息），Locality可以用于授权。

#### TPM内部的状态（启动计数器和定时器）
#### NV内存区域的值
#### 外部设备的状体（GPS，指纹读卡器，以及其他）
#### 灵活的Policy（通用型）
#### 示例1：智能卡和口令
#### 示例2：一个密钥的policy只能使用一个口令来授权签名操作
#### 示例3：一个PC状态，一个口令，一个指纹
#### 示例4：用于一个启动周期的Policy
#### 示例5：灵活的PCR的Policy
#### 示例6：用于一组许可的Policy
#### 示例7：用于NV内存1-100的Policy
## 基于命令的断言
## 多元素认证
## 混合Policy：在一个Policy中使用逻辑OR
### 生成一个混合Policy
### 示例：一个用于工作或者家庭电脑的Policy
## 创建Policy时需要考虑的因素
### 终端用户角色
### 管理员角色
### 候补角色
### 办公室角色
### 家庭角色
## 使用Policy授权一个命令
### 启动Policy
### 满足Policy需要的条件
#### 简单断言和多因素断言
### 如果是混合Policy
### 如果是灵活的Policy（通配型）
#### 满足被允许的Policy
#### 改变灵活Policy中被允许的Policy
## 认证过的Policy
## 总结
