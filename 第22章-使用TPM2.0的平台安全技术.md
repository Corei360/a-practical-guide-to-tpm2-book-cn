# 使用TPM2.0的平台安全技术
好了，到现在我们已经写完了整本关于TPM的书，并且你也阅读的了所有内容。或许我们试图让这本书有趣的努力成功了；又或者你超乎寻常地坚持了下来；又或者你仅仅是忽略了大部分内容直接跳到每章的总结部分。

不管是哪一种情况，我们已经到最后一哆嗦了。TPM博大精深并且很酷，它的安全程度就跟切片面包一样（这又是什么梗？），不用怀疑。并且TPM本身会提供级别很高的安全性。比方说，像微软BitLocker这样的应用程序可以使用TPM来保存一个硬盘加密密钥以及访问控制。

不仅如此，还有很多平台级别的技术结合TPM以及其他的平台或者厂商相关的安全特性，来提供更强大的安全解决方案。本章的目的就是介绍其中的三个技术，并说明它们是怎样集成TPM的。

## 三大技术
当前有三种主要的平台在使用TPM。这一章会概括性地介绍这些技术，以及它们是怎样使用TPM2.0设备的，还有它们怎样支持应用软件使用TPM。这章的描述试图尽量客观，不带任何偏见。因此，我们会避免对这三种技术作比较，并且避免市场相关的声明（但是，不得不说的是，这本书的出版得到了Intel的大力支持，包括出版费用。Intel致力于应用TPM2.0设备来构建更好的安全计算生态）这是一本TPM2.0的书，因此关注的重点是TPM怎样应用在这些环境中。为了维持中立性和准确性，以下关于这几种技术的章节均由相关公司的经验丰富的员工或者前员工完成。

### 一些术语
在我们介绍后面的内容之前，先定义一些术语：
* 可信计算基（Trusted Computing Base）：用于构建一个计算机系统安全环境的所有事物。主要是指，一组必须相信的软件硬件用来为系统提供安全保证。
* 经过测量的启动：这是一种启动方法，在这种启动方式下，前一个组件要测量下一个将要运行的组件。通常情况下，这些测量值会通过扩展操作被累计到PCR中。
* 信任链：组成“经过测量的启动”的一组操作构成的链。
* 用于测量的信任根（Root of Trust for Measurement）：一个信任链中被认为默认可信的基础组件。因此，它必须很小并且不可改变（在ROM中，或者受硬件保护）
* 静态信任根（Static Root of Trust for Measurement）：由上电到OS启动之前这个信任链中的最基本的组件。在服务器版本的Intel IXT技术中，SRTM就是CPU的微码。在其他的架构中，SRTM是一个ROM镜像。
* 动态信任根（Dynamic Root of Trust for Measurement）：由OS启动以后构建的信任链的基础组件。这允许系统构建一个动态的受测启动环境。在IntelTXT中，CPU的微码也是DRTM。DRTM有时候也叫做延迟启动。
* 可信代码模块（ACM）：ACM是经过IntelTXT数字签名的代码模块，这些代码模块由特殊的Intel TXT指令GETSEC启动。ACM是SRTM和DRTM执行之后紧接着要执行的模块。具体需要执行哪一个ACM模块以及需要执行GETSEC哪一个子功能，这都由执行GETSEC指令时的一个寄存器的值决定（Intel 有相关的SPec）。
* UEFI：现代BIOS。
* SEC 阶段：UEFI的安全阶段，复位后的第一段代码。
* PEI 阶段：UEFI的pre-EFI阶段。SEC之后要执行的diamagnetic。SEC和PEI共同构成BIOS启动块。

## Intel可信计算技术（Intel TXT）
Intel TXT技术在2002年就开始在客户端机器上交付，并且在2010年开始在服务器上交付。Intel TXT提供了提供了一个根植于微处理器的硬件的可信链，并将可信链扩展到了OS甚至到应用软件，当然相应的软件要实际应用这个技术才可以。

这一节首先从高层次描述Intel TXT，主要包括这个技术特性，它比仅仅使用TPM的方案更有优势。然后详细介绍这个技术是怎样使用TPM功能的。概括来说，Intel TXT技术相对于仅有TPM的解决方案的优势是，基于硬件的信任根，更小的TCB，以及ACM所做的软硬件配置检查。这一节会重点介绍这些技术优势是怎样实现的。

还有其他的Intel技术也会使用TPM，包括Intel Boot Guard。这一章并不会介绍这些技术，或者这些技术怎样使用TPM2.0设备的，因为Intel TXT是现在最流行最具代表性的TPM2.0设备应用技术。同时还要说明的是TXT有两类：一种用于客服端平台，另外一种用于服务器。许多操作的原理是共通的，但是我们将集中在服务器的版本，因为它使用了TPM功能的一个超集。

### 概述
Intel TXT的服务器版本可以防御BIOS攻击，复位攻击，rootkit，以及软件攻击，并且允许系统集成商和用户对保护进行多级配置。尽管这个技术确实可以阻止或者减少一些攻击，但它的初衷是通知用户和系统软件存在可能的攻击，并且如果检测到攻击就阻止启动。Intel TXT软硬件和TPM紧密地集成在一起，这使得TPM和TXT相关的寄存器在未经授权的情况下不能被访问。重要的测量值会保存在TPM中从而保证不被篡改，并且TPM还能阻止OEM和用户的Policy被执行未授权的修改。

那TXT究竟是怎样做到上述的特性的呢？简要的概括来说就是一个可信链会由Intel处理器或者芯片组硬件扩展到BIOS。然后，当OS启动以后，如果用户希望在OS层面进入安全模式，那么OS或者运行在OS上的软件会启动一个测量过的启动序列（DRTM）。这个测量过的启动保证在系统启动OS并进入安全模式之前系统不存在安全漏洞。一个可信链可能会由硬件一路扩展到最高层软件，使得系统管理员护着用户可以创建和使用Policy。这个可信链在执行组件之前总是会先测量它们。
#### Intel TXT平台组件
Intel TXT技术有很多平台组件：
* CPU和芯片组：芯片组中包含特殊的TXT寄存器，其中许多寄存器只能由ACM和CPU的微码来读写。
* CPU微码：这是固化在微处理器中的一组CPU微操作，其中包括一些CPU汇编指令和CPU内部操作。
* Intel ACM：这些ACM只能由Intel来构建，并且使用一个仅仅Intel知道的私钥来签名。公钥被固化到芯片组的寄存器中，因此只有使用正确私钥签名的ACM才可以被执行。ACM的启动是由Intel 的CPU微码来触发的，这作为微码的一个扩展来实现。对于服务器版本的额Intel TXT技术，有两类ACM，分别叫做BIOS ACM和SINIT ACM：
  * BIOS ACM包含几个子过程调用，其中的两个如下：
    * StartupACM调用是在系统上电启动SRTM时由CPU微码来实现的。它通常会测量BIOS的启动模块，或者说UEFI启动模块，以及BIOS的SEC和PEI模块。
    * Lock Config调用则由BIOS在退出部分BIOS测量模块之前实现。这个调用会做一些记录并锁定一些寄存器，从而防止恶意软件或者固件修改重要的硬件配置。
  * SINIT ACM仅仅包含一个调用，它是被OS或者OS之前的软件（tboot）调用的，用于创建一个测量过的启动（DRTM）。

这些ACM总是在特殊的CPU内部存储空间中运行，这个空间可以阻止DMA访问，从而保证ACM的代码和数据不会被篡改。

* GETSEC：这是TXT的一个特殊指令，它可以根据寄存器的配置启动特定的功能。这些功能能够启动特定的微码执行流来实现进入，启动，退出ACM以及退出测量过的启动环境（Measured Launch Environment）。GETSEC指令具体会执行哪一个子功能由一个寄存器的配置决定。BIOS ACM的Lock Config和SINIT ACM调用就是这样调用的。
* 使能Intel TXT的BIOS：BIOS中有一个表，叫作固件接口表（FIT），它会告诉微码和ACM 是否已经使能了TXT功能，BIOS ACM在什么位置，以及BIOS的那些部分需要被测量。

* TPM:
  * TPM的PCR用于存储启动过程涉及的组件测量值。其中的一些PCR只能由微码来执行扩展操作，有一些只能由ACM扩展。
  * NV索引用于存储验证过的启动过程需要的状态信息。

TCG的PC客户端平台TPM规范（google TCG PC Client Platform TPM Profile Specification）描述了PC兼容的TPM的细节。这个规范描述了PCR的数量和访问特性，测量BIOS启动代码的特殊接口，以及其他用于支持PC平台的TPM特殊功能。

* OS/middleware enabling for Intel TXT：OS或者中间件软件负责启动测量的系统加载过程。在某些情况下，这可能是一个运行在OS之下的应用或者软件模块；在另外，它还可能是一个商业虚拟机管理软件（VMM）包。
* 使用Intel TXT来做安全相关决定的高层应用软件：Intel的Mount Wilson是其中一个例子。如果想了解更多例子及更详细的解释，请阅读《Building the Infrastructure for Clound Security：A Solutions View》。

所有以上的组件共同协作来实现Intel TXT技术。

#### Intel TXT启动顺序
现在我们进一步详细地介绍一种可能启动顺序。如果你想了解更多这方面的内容，请参考《Intel Trusted Execution Technology for Server Platforms》。

在进入正题之前我们先说明一下错误处理，这样一来我们就不用不断地重复下面的错误处理过程：如果在启动过程中的任何一个地方出现了错误，芯片组中的一个寄存器会会记录响应的错误信息。这个寄存器，TXT.ERRORCODE，只能由ACM和微码来写，这样就可以阻止权限低的或者恶意的代码将错误信息清除。这个寄存器中的错误信息能够在后续阻止测量的启动过程，稍后我们将介绍。

图22-1和图22-2描述 了Intel测量的启动过程以及其中各种各样的模块是怎样和TPM交互的。图22-1是一个由上电到启动一个可信OS的完整过程。这个过程包括OS启动之前的SRTM以及由OS启动的DRTM。图22-2提供了关于安全启动过程的更多信息，尤其是用来验证平台和系统软件是否可信的步骤。

图22-1描述的启动过程包含两个阶段：SRTM阶段和DRTM阶段。SRTM由CPU微码开始，直到OS开始启动。DRTM阶段由SINIT ACM开始知道OS完全启动。

第一部分由系统上电开始，它能够阻止BIOS和复位攻击：
1. 微码：当复位信号被释放以后，微码会检查BIOS的FIT从而知道BIOS ACM在BIOS镜像文件的什么位置。微码会验证BIOS ACM的签名，并且对ACM做一些合规性检查。如果没有问题——也就是说ACM没有被破坏，并且是正确的ACM——微码就会在保护的CPU内部存储中启动ACM。
2. Startup ACM：这个BIOS ACM包含一些可以由微码或者BIOS触发的不同程序入口。Startup ACM调用由微码在平台上电或者复位时启动。这个调用的主要功能是测量BIOS特定的内容，这些内容必须保证可信，从而进一步保证系统的可信，同时这个调用还需要将测量值扩展到PCR0中。需要测量的BIOS区域在FIT中指定，这是由BIOS OEM来定的。FIT的一些重要的区域本身和复位向量，以及一些BIOS其他区域需要被测量，BIOS ACM会保证这一点。BIOS的其他区域可以选择性地测量，这需要BIOS开发者合理地配置FIT表来增加正确的对应区域。不需要测量整个BIOS镜像，并且在正常启动过程中可能会被修改的任何区域都不会被测量，因为一旦包含这些内容启动过程将会失败。最低的要求是，为了保证系统的完整性，一定要测量BIOS的启动模块——这个启动模块包括基本的系统和内存初始化代码。如果StartACM检测到一个错误（很可能意味着这是一些安全问题），它将会在TXT.ERRORCODE中设置一个错误代码然后复位CPU，然后微码会让CPU重新执行复位向量。在这种情况下，仅仅可能启动一个未经验证的环境。如果StartupACM成功执行，接下则会执行BIOS代码。

3. BIOS继续扩展静态信任链：BIOS将测量额外的BIOS代码并把测量值扩展到PCR0，以及测量其他的平台组件并扩展到其他的PCR中，BIOS通过这样的方式来继续延伸信任链。BIOS还会将自己所测量内容的记录扩展到一个PCR中。所有BIOS信任边界上的代码都必须在执行之前被测量。在BIOS执行任何未经测量的代码之前（BIOS可信边界之外的代码），它都会调用BIOS ACM来锁定平台配置从而阻止不可信的代码修改平台的配置。这些BIOS ACM的调用同样也会做测试和安全检查，从而保证系统的完整性。
4. Option ROMs：除非这些ROM由OEM来提供，否则option ROMs就在可信边界之外。ROM的代码将会被测量并扩展到PCR2中，而ROM的配置信息会被测量并扩展到PCR3中。
5. OS启动：当BIOS执行完成以后，它会启动到OS。OS运行在正常的没有被验证的模式下，但是它会被锁定并加载，然后来执行系统启动的DRTM阶段。

启动过程的第二部分由GETSEC（SENTER）指令开始，这个指令是由OS或者运行在OS中的软件触发的。这部分可以提供动态信任根测量，比如SINIT ACM和MLE（有时候也是VMM）

6. 测量启动：当OS想要启动到可信模式时，它会执行GETSEC（SENTER）指令。这会触发一个验证SINIT ACM的微码流，验证过程与BIOS ACM类似，然后SINIT ACM被加载，然后开始执行。
7. SINIT ACM：SINIT ACM会通过检查TXT.ERRORCODE寄存器来验证系统是否存在安全问题。它还会针对特定的安全问题做硬件配置检查。然后测量可信OS代码。ACM还包含LCP（Launch Control Policy）引擎，这个引擎用于Policy检查，检查又包括将测量过的OS代码和PCR与已知的正确值比较。如果SINIT ACM的执行出现错误，将会产生一个复位信号。如果一切正常，ACM将会执行测量启动，并且OS就会进入安全模式。这个就称作MLE（Measured Launch Environment）。SINIT ACM，policy，OS代码的测量值会被扩展到PCR17和PCR18中。
8. 可信模式：此时，一个可信的环境已经被建立起来了，并且OS又权限访问TPM的Locality2以及动态PCR（什么叫dynamic PCRs？）。可信OS通过测量其他的OS组件和配置信息并扩展到PCR18-22中来延续动态可信链。
9. 应用：本地应用可以使用PCR中的值来密存一些秘密信息，这个信息只能在平台处在相同的可信环境中时可能解封。举例来说，OS可以密封一个用于加密隐私和特权信息的密密钥。只有当平台成功执行测量启动后，OS才能恢复这个密钥并解密数据。这个过程有时候又叫做local attestation。Remote Attestation则是指外部机构使用PCR的值来做可信决策——可能是将生产环境网络连接到可信平台时隔离不可信的平台。
10. 终止：最后一个阶段是OS终止可信执行环境。这个终止可以是平台关机或者仅仅是退出可信模式，在后者的情况下OS可以在不重启的情况下通过执行另外一次测量启动，从而重新进入可信模式。MLE关闭之后，OS就不能再访问TPM的Locality2了。

上述这些内容看起来有很多很多细节，但是我们已经略过了Intel TXT Policy的底层信息，ACM执行的安全检查细节，以及怎样使用TXT NV索引来交换TXT状态，同时还有TXT相关的BIOS使能和配置过程。

### TXT怎样使用TPM2.0
因此，TPM到底是怎样应用于这个技术中的呢？Intel TXT主要使用了TPM的PCR和NV索引。TPM2.0的一些其他特性可以帮助我们搞清楚PCR和NV索引是怎样被访问和使用的：特殊的由硬件触发的TPM命令，Policy命令，以及Loality。我们将在这里概括性地介绍它们。

#### NV索引
#### PCRs
### 总结Intel TXT

## ARM TrustZone
### 概述
### TrustZone是一个架构属性
### TrustZone保护的目标
### 系统级安全
### TrustZone实现
#### NS位
#### Monitor
##### 安全/非安全切换
#### 中断
#### 与TPM的关系

## AMD安全技术
### 基于硬件验证的启动过程
### AMD平台上的TPM
### SKINIT
## 总结
