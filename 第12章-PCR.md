# PCR
平台配置寄存器是TPM必需的特性之一。它们最初的应用是用于提供一种密码学的方式记录（测量）软件的状态：包括平台上运行的软件和软件使用的配置数据。PCR的更新方法叫做扩展，扩展是一种单向的哈希操作，从而保证测量值不被篡改。这些用于测量的PCR可以被读取来报告这些软件的状态。这些PCR的值可以被签名然后用于更加安全的报告，这被称作认证（或者说引用）。PCR还可以被用于扩展的授权policy从而限制其他TPM对象的使用。

TPM从来不对测量的结果做任何判定。单单根据TPM内部的信息来看，并不能确定测量结果的好坏，或者结果是否安全可信。在测量软件时，TPM仅仅用PCR来记录测量值。至于是否安全，这要到应用程序真正使用PCR用于policy授权的时候，或者是远程请求者请求一个签名认证（quote，引用）然后判定可信性。

TPM2.0新增加的关于PCR的特性是，TPM不再将PCR的哈希算法固定为SHA-1。哈希算法现在可以修改了。有一些TPM的实现包含bank的概念，每一个bank实现一种不同的算法。

一个TPM会实现一定数量的PCR：比如说，PC上使用的TPM实现了24个。这些PCR按照惯例被分配给各种各样的软件层使用，软件类型从早期启动代码到操作系统和应用。这些PCR的分配还可以分为以下两类：需要运行的软件（通常是偶数序号的PCR），和用于定制启动过程的配置文件（通常是奇数序号的PCR）。

## PCR的值
PCR最初的应用场景是用于表示平台软件的状态，重要软件运行到当前阶段时的历史信息（包括配置信息）。TPM上电时会初始化所有的PCR，初始值由TPM平台相关的规范定义，通常是全0或者全1。命令调用者不能直接向PCR写值。相反，PCR的值是通过被TPM成为extend（扩展）的操作，我们在第2章已经讨论过了。从密码学的角度来看，这个过程如下：

PCR new value = Digest of (PCR old value || data to extend)

TPM将会把需要加进来的数据连接到旧的PCR值中。要被扩展到PCR中的数据几乎总是哈希值，尽管TPM并没有限制一定是哈希值。然后TPM会对这个刚刚连接好的值做哈希，然后将新的哈希值存储到PCR中。

系统重启以后，整个平台的运行由CRTM（Core Root of Trust Measurement）开始。CRTM会测量接下来将要运行的软件并将测量值扩展到一个偶数索引的PCR中。然后CRTM还会将软件的配置信息扩展到一个奇数索引的PCR中。这个被测量的软件，可能是BIOS，反过来又会测量和扩展它的下一级软件，这或许是MBR。这个测量链就这样继续下去直到早期的系统内核代码或者这个之后。这个过程中，重要的安全配置文件也会被测量。

最终测量的结果就是PCR的值表示了所有扩展到PCR中的测量历史。因为安全摘要机制的单向属性，索引没有办法撤销一个测量。（将PCR的值变成过去的某一个值）

表12-1是 PC客户端规范为PCR分配的功能。

表12-1

测量过程的安全性取决于CRTM的安全性。CRTM作为第一个运行的软件，它是不能被测量或者验证的。CRTM就是所谓的信任根。平台制造商可以通过将CRTM存储于ROM中，让它变得不可修改来保护CRTM，如果不在ROM中也可以设置禁止升级来保护。但是因为有可能因为bug需要修改CRTM，另一种方法就是要更新的代码要附带签名，CRTM在更新自己之前先验证这个签名。

Linux的完整性测量架构（Integrity Measurement Architecture）在内核中集成了启动时测量功能。IMA策略决定了哪些软件需要被测量。这些被测量的软件通常包括库文件和启动时以root权限来执行的代码，以及决定Linux启动路径的配置文件。IMA通常情况下不会测量用户态的应用程序。

### PCR的数量
### PCR命令
### PCR用于授权
## PCR用于认证
### PCR引用详解
### PCR属性
### PCR授权和policy
### PCR算法
## 总结
