# 使用TPM的应用软件
尽管已经有10亿以上的TPM设备被部署在商业个人电脑和服务器上，仍然仅有很少人知道TPM。同时当许多知道TPM的人了解到已经有很多针对TPM的应用时也会感到惊喜（这说明TPM的广泛应用和被人熟知还有很长的路要走）。其实现在有很多种方法来帮助我们编写应用TPM1.2设备的软件。对于TPM2.0来说，因为现在仍处于应用的初期，所以我们看不到很多可直接应用TPM2.0的软件也不足为奇了。这本书的目的就是帮助你基于TPM2.0的基本功能和高级功能开发相关的应用程序。

这一章首先介绍各种各样用于和TPM硬件交互的软件接口。然后介绍几个已经在使用TPM的应用。这其中我们会指出一些在我们看来应该使用但却没有使用的软件（期望读者可以改进它们），这或许是这个章节中最有意思的部分。

最后我们还给程序员提出一些在使用TPM开发应用时的一些建议和他们应该注意的地方，以及当前应用软件是如何处理与之相关的问题的。

## 用于和TPM设备通信的应用软件接口
当前使用TPM1.2和TPM2.0的软件有很多中类型，我们可以根据它们使用的应用程序接口分为以下几类：
* 直接使用TPM设备的私有软件
* 使用中间件来和TPM设备通信的旧应用，比如说PKCS#11和微软的CAPI。当PKCS#11可以在TPM2.0上使用时，这些应用仍然可以使用。这些软件在所有支持TPM1.2的操作系统上都是可用。微软的CAPI更是从Win8就开始同时支持TPM1.2和TPM2.0。
* 使用TSS接口来和TPM设备通信的应用（IBM，Infineon和NCP都有自己私有的TSS，同时也有叫做TrouSerS的开源TSS。注：现在它们应该是全部转向TPM2-TSS（github）了）。当然这些都是针对TPM1.2的，同时他们也正在如火如荼地开发TPM2.0版本的接口。
* 使用JAVA接口来和TPM设备通信的应用。目前仅有TPM1.2版本的软件，不过TPM2.0版本的软件应该很快就会出现。使用JAVA接口的设备主要是移动设备，尤其是运行Android系统的平台
* 使用微软TBS（TPM Base Services）的windows应用。它们可以支持TPM1.2和TPM2.0。当然新规范中增加的功能只有TPM2.0设备才支持。
* 支持TPM2.0的微软TSS.net，它同时附带有一个TPM2.0模拟器。不过需要说明的是，TSS.net不兼容TCG标准，并且现在只能在Windows平台上应用。

第一代使用TPM的软件是在具有第一版TPM的设备上运行的私有软件。比如说IBM的口令管理器和文件系统加密器，它们使用TPM来加密软件中涉及的密钥。Dell，HP，Infineon也有各种各样的类似软件。一般来说，这类软件运行良好，但是它们都是功能比较单一的应用案例。

另外一类使用TPM的应用来自于密码服务供应商（CryptographicServiceProviders）。它们主要包含两种主要类型：一种使用CAPI，另外一种使用RSA公司的PKCS#11。任何应用都可以通过这两种API来使用TPM的密码学服务。幸运的是，大多数软件都使用了以上两种API，使用它们的好处是显而易见的。大家都知道，开发密码学接口是非常困难的，尤其是在需要考虑容易受到攻击的地方，比如如何防止侧信道攻击。目前比较靠谱的方式就是让密码学专家来实现这些密码服务接口。另外，在政府应用环境中，这些密码学服务需要通过NIST的相关认证才能被使用。

以上两种API都提供一些钩子接口，它们可以用来替换那些之前用软件来实现的密码学服务。这个特性可以利用TPM基于硬件的密码服务接口来抵御软件攻击。在window上，使用CAPI和PKCS接口的此类密码服务供应商都有。比如，SecurityInnovation，WaveSystems，Infineon和Lenovo都有类似的实现。这种密码服务通常是和计算机供应商绑定在一起的。值得注意的是，Infineon的CSP可以检测系统中可以使用他们服务的应用，从而让用户通过它们的服务来使用TPM。在其他的操作系统上，比如Linux，BSD，MAC OS，Solaris，PKCS#11实现了使用TPM产生公钥和随机数。并且这些实现是免费的。另外，一些公司也实现了中间件来用于构建基于TPM的密码服务，比如Charismathics。

使用上述旧的接口（PKCS#11和MS CAPI）的问题是只能使用TPM的基础功能，比如说密钥生成和签名功能。所以想要利用TPM来做计算机系统健康状态认证或者米密钥迁移的软件就不能使用这些中间件。这客观上促成了TSS（TCG software stack）规范的产生。IBM开发了一个叫做TrouSerS的开源TSS实现，后来来自意大利Politecnico di Torino大学将它移植到windows平台上。当前TSS仅仅支持TPM1.2，针对TPM2.0的更新正在紧张开发中。（到2017的版本已经比较成熟了）

相较于JAVA，TSS软件库更适合用C语言开发。因此，MIT的一些研究者开发了JAVA版本的TPM应用接口。（官网上溜了一圈，github上简单看了看，感觉好久没更新了）。

自Windows Vista开始，微软开始通过TBS接口提供几乎可以直接访问TPM的应用接口。TBS接口接收符合TPM规范合适的字节流并返回相应的命令响应字节流。因为TBS是一个相对底层的接口，所以你可以使用很多上层软件库，这些库可以将应用层接口转变成TPM字节流。

除了比较完善的TPM功能，TBS还提供了以下额外的功能。第一，它可以支持多线程。这主要通过内部用于维护命令的队列来实现。第二，因为TPM支持使用save和load命令来做上下文管理，TBS利用这一点来实现虚拟TPM，从而支持多种应用理论上拥有不受限制的密钥存储空间，并且应用之间互不干涉。第三，应用软件通过TBS上下文来提交TPM命令，TBS上下文能够自动管理TPM资源和内部上下文，例如进程推出时它们会负责清理相关资源（linux平台上的tpm2-software/tpm2-abrmd也有类似的功能，还没有仔细研究）。

此外，windows平台在TPM的管理基础上实现了分层安全机制。它解决了由一些TPM命令引起的问题，这些问题主要是TPM命令可能会影响操作系统及应用的稳定性和正确执行。比如说，PCR的更新应该由系统的可信基来授权，但是TPM并有相关的规定（注：这个看起来很致命，不知道规范有没有更新，如果没有，又是基于什么样的考虑？）。因此，在windows Vista和Windows 7中只有管理员有权访问TBS服务。在Windows 8中，TPM命令被分成以下几组：
* 不能访问：包括TPM2_ContextSave 和 TPM2_ContextLoad。
* 仅限于管理员权限访问：包括TPM2_PCR_Extend在内的隐私敏感操作。
* 常规访问：秘钥的创建和使用等等。

同时，系统的管理员可以编辑管理员权限和常规权限中的内容，从而可以做定制化管理（注：这个还是要想好了）。此外，操作系统会在注册表中保存TPM相关访问入口的授权值得副本。《Using the Windows8 Platform Crypto Provider and Associated TPM Functionality》这个文档中详细介绍了这一点。

除了比较底层的TBS外，windows还提供了实现TPM部分功能的五种高层应用接口。

## TPM管理和WMI
windows通过GUI工具和可以脚本化的远程编程接口WMI提供了很多TPM管理功能。这些管理功能包括开启，清除和关闭TPM等，并且它们能够无缝兼容TPM1.2和TPM2.0.

### 平台密码学服务
大多数的windows应用通过一组叫做CNG（CryptographyNextGeneration）的接口来使用密码服务。CNG将密码学服务封装成统一的编程接口，这些接口的实现可以是软件也可是硬件（例如HSM）。例如windows 8提供平台密码学服务（PlatformCryptoProvider），它可以让用户选择使用TPM来保护相关的密码学应用。同时，PCP也有一些与TPM功能类似的特性，比如“引述（quoting）”和秘钥认证。

### 虚拟智能卡
windows 8还进一步提取了TPM中与智能卡相似的功能，并将它们封装成类似虚拟智能卡的应用。企业和网络登录中都有相关的应用。

## 使用TPM设备的应用软件
表4-1是当前正在使用TPM的应用软件，同时包括他们使用的软件接口和支持的操作系统。所有的应用都支持TPM1.2，有一些也会支持TPM2.0（会标注出来）。

“表”

正如上表所示，已经有许多应用在使用TPM设备了。甚至有一些大型的公司都在使用这些软件。其中，被广泛应用的BitLocker使用了TPM的一些扩展功能。WaveSystem的EmbassySuite也是如此。但是也经常会出现因为一个系统上运行多个TPM应用而产生冲突的情况。

在TPM1.2规范中，只有一个SRK（storage root key），所有使用TPM的应用必须共享这个秘钥的授权。但是不幸的是，规范并没有一个统一的SKM创建方式。你可以将SRK的授权配置成不需要授权，为人熟知的20字节0，或者是口令的哈希值。更严重的是，TPM所有者授权也比较脆弱，因为它既可以用来复位字典攻击机制，也可以用于复位整个TPM或者创建认证秘钥。这从应用的角度来说是不合适的，我们之前也提到过。

更加不幸的是，TPM所有者权限还可用来授权分配NVRAM空间，这意味着需要使用NVRAM的应用必须知道这个授权值。不同的应用拿到TPM所有者权限后，将权限口令设置成
随机值，这些值将由统一的后台管理应用维护，而终端用户甚至可能都不知道。实际上就有这样的应用，因为不知道如何正确地和这些后台管理应用交互，最终让他们没办法工作。

这种问题在仅仅使用PKCS#11或者MSCAPI的应用上有所减缓，因为这两种接口只允许一种应用可以管理TPM。但是遗憾的是，这两种接口不支持高级TPM功能，比如认证功能（这个认证和前文说的TPM内部的认证功能还不太一样）。当然类似的问题也在慢慢改善，比如说WaveSystem的软件可以支持TPM的认证功能和BitLocker。

尽管TPM2.0规范仍然需要在授权上做一些协调工作，但是它可以支持用户使用多个SRK。这样就可以根本上解决不用应用的授权问题，从而大大减少不同应用同时使用TPM时需要做的协调工作。

在调研TPM应用时我们发现，商业软件支持大多数我们容易想到的TPM应用场景。但是，也有一些特别明显的TPM应该被应用的场景却没有在商业软件中出现。

## 应该用却没有使用TPM的软件
近年来，基于web的应用数量增长了不少。其中主要是用于备份和存储的应用。尽管很多公司有这样的服务，但是到目前为止我们还有发现可以支持用户将密钥存储到TPM的应用。如果应用能支持的话，就可以与TPM在多台机器上复制备份的功能完美结合。因此，这对于开发者来说是一个好机会。

远程管理软件是另外一个越来越有用的应用。许多公司提供可以允许一台机器远程接管另一台机器的服务。比如说你可以远程管理你的网络，或者远程帮助家人解决计算机问题。但是，这些服务同样也都是使用我们熟悉的口令来做访问授权。尽管使用一个特别难记住的口令密码可以增加一些安全性，但是有时候这真的很麻烦，忘记密码可以让人抓狂。所以在这些地方，看起来使用TPM是一个理想的解决方案，这样远程机器只允许与它建立公私钥连接的机器访问（可以理解为一种基于TPM的远程认证机制）。现在还没有商业应用这样使用TPM，甚至大部分的应用都不支持使用其他的密码设备（智能卡）来增加安全性。而且原因也不是缺乏相关的软件开发包，因为确实有这样的开发包可供使用。

## 开发基于TPM1.2的应用
在使用TPM构建应用软件之前，很重要的一件事是决定是否要使用超出PKCS和MS CAPI功能之外的TPM高级功能。如果不适用高级功能，那就可以使用这两种接口。这样以来，这些应用也可以在没有TPM设备的系统上运行。但是如果要使用诸如设备认证，扩展授权，Localities或者NVRAM，那你就没得选择，必须使用定制化的TPM接口。

幸运的是，也有一些定制化的API用于开发这种应用。因为tss1.2让人难以理解，所以有人开发了替代的软件。MIT开发了TPM/J，旨在提供一种面向对象的tpm开发接口。Graz大学的IAIK提供了TrustedJava（感觉已经很久不更了）。Sirrix提供了microTSS，试图让TSS规范变的简单。

另外，IBM在SourceForge上发布了TPM模拟器和命令行工具。这样以来就可以使用脚本文件练习使用TPM命令。

虽然微软的TBS开始时仅仅有基础的TPM应用接口，但是随着它的不断完善，最后很可能成为编写TPM应用的好帮手。TBS相关的最大新闻来自Windows8，此时它抽象出了TPM1.2和TPM2.0的不同，从而使所有相关的API都能兼容两种设备。这对于目前仅仅支持TPM1.2功能的应用来说非常有用。同时微软也发布了可以直接向TPM设备发送命令的TSS.net，当前它还没有用于TPM2.0新功能的高层次接口。

## TSS.net和TSS.C++


























