# TPM软件栈
这本书的初衷是介绍TPM2.0设备。但是若果没有配套的软件，TPM就是一个满载燃料却没有司机的汽车，它有巨大的潜力，可是哪里都去不了。同样也是为了本书剩余部分做铺垫，这一章给大家介绍一下TPM的“司机”：TSS。理解这一章的内容将有助于你学习本书后续的示例代码。

TSS是TCG的软件标准，TSS包含几个可以移植的软件层，这样就允许应用软件使用其中间层。基于TSS编写的软件应该可以运行在任何实现TSS标准的系统上。这一章介绍了TSS的软件分层，其中重点描述SAPI和FAPI，其他层则在概述中描述。

## 软件栈概览
TSS包含以下由高到低的几层软件：FAPI，ESAPI，SAPI，TCTI（TPM Command Transmission Interface），TAB（TPM Access Broker），RM（Resource Manager），和设备驱动。

大多数的用户层引用程序基于FAPI开发就可以了，因为FAPI实现了TPM百分之八十的常用应用场景。使用这一层开发应用就像是使用JAVA，C#等高级语言开发应用一样方便。

往下一层是ESAPI，它需要你对TPM了解很深，但是同时提供了会话管理以及加解密的辅助功能。这有点像使用C++开发应用程序。写这本书是ESAPI的规范还在制定中，这一章不做介绍。

应用程序也可以直接基于SAPI这一层，但这需要你对TPM了如指掌。这就像是使用C语言编写应用程序，而不是用高级语言。它提供了TPM的所有功能，但是要想用好它你必须对TPM有很深的理解。

TCTI层用于向TPM发送命令并接收TPM对命令的响应。应用可以直接通过TCTI发送命令的数据流并解析接收到的响应数据流。这就像是使用汇编语言来编写应用程序。

TAB这一层主要负责多线程环境下TPM资源的同步。也就是说它允许多个线程同时访问TPM而不发生冲突。

因为TPM内部的存储资源非常有限，所以需要一个资源管理器RM，它的原理于虚拟内存管理类似，它可以将TPM对象和会话换进换出TPM。

最后一层就是设备驱动，它主要是控制通信外设与TPM互相传输数据。如果你愿意的话，直接调用设备驱动接口来编写应用程序也是可以的，当然这就像是你用二进制数据编写程序一样。

图7-1描述了TSS的组件构成。主要注意以下几点：
* 尽管通常情况下，对于应用来说只有一个可用的TPM设备，但是有多个TPM设备也是可以的。其他的TPM设备可以是软件实现的TPM，比如微软的TPM模拟器；也可以是通过网络来远程访问的TPM，TPM设备有这样的远程管理功能。
* 通常来说，SAPI以上的软件是线程相关的。
* SAPI以下的组件是与TPM硬件相关的。
* 尽管图7-1没有体现这一点，实际上TCTI可以作为RM和设备驱动的接口，这时候TCTI在软件栈中有多个层次的角色。
* 到现在位置，TAB和RM最常见的实现方式是为一个模块实现。

图7-1

接下来分别介绍TSS的每一层内容。

## Feature API
## System API
### 命令上下文申请函数
### 命令准备函数
### 命令执行函数
### 命令完成函数
### 简单的代码示例
### SAPI测试代码
## TCTI
## TPM访问中介（TPM Access Broker）
## 资源管理器
## 设备驱动
## 总结
