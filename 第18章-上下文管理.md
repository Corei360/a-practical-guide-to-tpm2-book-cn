# 上下文管理
In general, we don’t prevent things unless there is a good reason for that. Put another way, we try to allow anything that doesn’t cause a security problem.

					David Wooten,

					During an e-mail exchange about context management

相对于TPM大量的功能来说，它的内存是非常受限的，这主要是为了降低成本。这就意味着对象，会话，以及中间结果必须在必要的时候换入换出TPM设备。这很大程度上和虚拟内存管理器将内存页在磁盘中换入换出一样。这两种情况中，应用程序都会认为它们能够访问比实际情况更多的对象和会话（TPM），或者更多的内存（虚拟内存的情况）。

如果一个系统上确定只有一个应用会向TPM发送命令，那这些交换操作可以由应用本身来完成。但是，当同时有多个应用或者进程在访问TPM时，就需要TSS软件栈的两个组件：TPM访问中介（TPM Access Broker）和资源管理器（Resource Manager）。

这一章描述了TAB和RM的高层次架构。然后介绍TPM用于支持对象，会话，结果交换的特性和命令。同时还有相关命令是怎样处理交换实体的细节和特殊情况。

## TAB和资源管理器：高层次描述
TAB和RM首先是在第7章中作为TSS的软件层来描述的。这一节会提供一些TAB和RM内部细节。

TAB和RM将TPM应用、进程 与 仲裁多进程访问TPM和对象、会话、结果在必要时换入换出TPM的繁杂事务隔离开来。TAB和RM关系非常紧密，并且通常会被集成到相同的软件模块中。根据系统设计具体情况，它们可能是TPM设备驱动的最上面一层软件，或者被集成为一个独立守护进程，进程处于TSS SAPI之下以及TPM设备驱动之上。

### TAB
TAB的职责非常简单：仲裁多进程同时访问TPM。最小的要求是，必须保证所有进程在命令数据流开始发送到TPM直到从TPM接收命令响应数据的时间段内，没有其他的进程与TPM通信。下面是在没有TAB的时候，一些多进程访问TPM冲突的例子：
* 进程A的命令数据开始被传送到TPM，在传送完成之前，进程B的命令数据开始发送。这样一来，发送到TPM的数据就是两个命令的混合，并且TPM很可能会返回一个错误代码。
* 进程A发送了命令，但是进程B读取了这个命令的响应数据。
* 进程A的命令数据已经被发送到TPM中，然后当A读取命令响应数据时，进程B开始发送命令数据。
* 进程A创建并加载一个只能它自己使用的秘钥。进程B保存了这个秘钥的上下文（使用TPM2_ContextSave命令），之后在某个时间加载这个秘钥的上下文（使用TPM2_ContextLoad命令）并使用开始使用这个秘钥。

一个TAB可以用以下两种方式实现：使用TPM锁或者不使用TPM锁。

在带锁的架构中，可以设计一种通过软件向TAB发送锁请求的机制。这个请求会指示TAB，在发送锁请求的进程完成命令之前不允许别的进程访问TPM。这个机制就保证了TPM在独立命令不被中断的情况下完成多个命令的处理。有趣的是，如果应用能够自己实现资源管理，这种架构将不需要RM。应用可以首先向TAB请求锁，然后在向TPM发送命令的同时管理TPM的上下文（这个管理包括在释放锁之前清理自己占用的资源，比如删除对象，结果，和会话）。这种架构的缺点（Achilles heel 艾吉利斯的脚后跟（来自希腊神话））是，这个应用可能在释放锁时失败，这将阻塞所有其他应用。当然可以通过设置超时来缓解这个问题，但是超时又会造成对一个应用独占TPM时间的限制（有些操作可能时间就是很长，这时候超时的设置就麻烦了）。结果就是，应用不得不处理一些关于TPM上下文的边边角角的复杂管理任务，因为设定超时之后，应用不能保证超时到来时TPM是出错还是正在执行命令，如果因为遇到执行很长时间的命令，中间因超时返回，应用可能需要重新发送命令等等。TCG TSS工作组刚开始想用这个方案，但是最终在微软的Paul Englang给出一些建设性建议之后否决了。

无锁架构相对来说更简单，它允许任何进程在不受其他进程访问TPM的情况下，独占地发送TPM命令和接收命令响应。这种机制减少了应用程序独占访问TPM的时间和进程发送命令、接收命令响应占用的时间。这个架构需要背后有RM的支撑，因为多个相互竞争的应用不可能相互管理它们的对象、会话和结果。比如：
1. 一段时间内进程A恰好是唯一访问TPM的进程，在此期间它启动了三个会话并加载了三个秘钥。
2. 进程B准备好与TPM通信并且想要创建一个会话和一个秘钥。如果TPM只有三个用于会话的内存槽位，和三个用于对象的内存槽位，进程B必须首先清除进程A至少一个会话和一个秘钥对象。
3. 这就要求进程B能够管理进程A的状态——从进程隔离和软件复杂度的角度考虑，这不太可能。没有一个中心话的RM，应用程序必须管理所有的TPM上下文。这几乎不可能，而且这确定无疑地允许应用之间的TPM上下文混合在一起。

因此，这种情况下需要一个RM。

### 资源管理器
RM负责处理对象、会话、和结果换入换出TPM的细节，这个处理对应用来说是透明的。在高度嵌入式的环境中，单用户应用可能会选择自己处理这些人物，但是之前我们也讨论过，大多数系统是多用户的，并且需要RM的存在。作为类比，想象一下如果所有的PC应用程序必须自己将虚拟内存换入换出硬盘，而不是依赖操作系统来做这件事情。RM在处理TPM的访问时与上述例子中操作系统的角色类似。

### 资源管理器的操作
## 对象，会话，命令序列的管理
### TPM上下文管理特性
#### TPM内部存储槽
#### 特殊错误代码
#### TPM上下文管理命令
### 与开机关机事件相关的特殊规则
### 状态图
## 总结
