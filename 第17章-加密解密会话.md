# 加密解密会话
2B or not 2B, that is the question
                                
				 --Dave Challener，在TCG TSS工作组讨论加密解密会话期间。

第13章简单地介绍了加密和解密会话。你可能还记得，这些都是单个命令相关的修饰符。这一章将会详细介绍这两个会话修饰符：它们用来做什么，它们的实际应用，它们的一些限制，怎样设置它们，以及一些代码示例。

## 加密解密会话是做什么用的？
简单来说，加密解密会话保护秘密信息在不安全的信息传输媒介中传送。命令调用者为了保证数据的机密性，可以使用一个他和TPM都知道的加密秘钥来加密密令参数。加密秘钥部分由启动会话的参数决定（稍后介绍更多）。一个解密会话之后会通知TPM第一个参数被加密了。这就意味着TPM受到命令的参数后必须解密它——比如名称，解密会话。对于一个命令响应来说，一个加密会话表明TPM已经加密了第一个命令响应参数，这也是会话称作加密会话的原因。调用者在受到加密的命令响应参数后，他会使用命令响应参数解密秘钥来解密数据。

加密解密会话支持两种类型的对称秘钥模式：XOR和CFB。CFB模式的安全强度较高，但是这需要TPM和命令调用者需要支持哈希算法和加密算法。XOR仅仅要求支持哈希算法，并且适合小型代码工程，但是安全性相对较低。

## 实际的应用案例
所以，到底这些加密的模式有什么好处呢？简单快速的回答就是它们有很多用处；参考TPM2.0规范的第3部分中每个包含TPM2B数据作为第一个命令或者命令响应参数的命令。所有这些参数都有可能被加密。

一些小的通用案例如下：
* TPM2_Create：第一个命令参数inSensitive，这是一个包含口令的数据结构（叫做userAuth）。这个参数很可能以加密的方式发送到TPM，这就要求会话被配置为解密会话。
* 写入或者读出TPM NV索引区域的机密数据。假设你想使用TPM NV索引存储区域保存口令和个人信用卡等信息。在发送到TPM或者从TPM接受之前将这些数据加密可以保护它们不被泄露。
* 当我们通过网络与一个远程TPM通信时，使用加密解密会话就显得更加重要。假设你想把秘钥存储到远程服务器，然后在客户端上恢复它们。以明文的方式发送到服务器显然是不安全的。SSL会话可以缓解网络监听的缺点，但是秘钥仍然会以明文存在于客户端和服务器上的多层软件中。加密解密会话可以大大减小攻击面。

## 加密解密的限制
机密解密会话对参数的加密解密有一定的限制，同时一个命令对加密解密会话的数量也有限制。

只有命令的第一个参数可以被加密，并且只有命令响应的第一个参数可以被解密。并且在这两中前提下，参数还必须是TPM2B类型的参数。第一个参数不是TPM2B类型的命令不能使用机密会话发送到TPM；同样地，第一个参数不是TPM2B类型的命令响应也不能通过加密会话接受。

你已经在第13章中学过，命令可以有三个会话参数。但是，一个命令最多只能由一个加密会话和一个解密会话。如果一个命令同时允许使用解密和加密会话，可以使用具有两种属性的会话或者两个独立的会话（一个会话分别配置一个属性）。

所以我们到底怎样使能加密解密会话呢？

## 加密解密配置
乍一看，将会话配置成加密以及（或者）解密会话非常简单。对于一个普通的会话来说，所有你需要做的事就是设置命令授权区域中的会话属性：sessionAttributes.decrypt以及sessionAttributes.encrypt。

当然了，事情常常不是这么简单的，这里就更是这样了。对于一个解密会话来说，调用者必须以合适的方式加密第一个参数。同理，对于加密会话来说，命令调用者必须以合适的方式解密从TPM收到的第一个命令响应参数。有两种加密模式可以用于加密解密会话：XOR一个CFB模式。启动会话的时候会设定加密模式。这两种模式都要求明文和密文具有相同的长度，因此数据流的长度不会变化。加密过程会加入会话nonce，这就保证了加密数据块只能使用一次。

对于XOR模式来说，它会使用一个mask（一个一次性的填充）与将要加密或者解密的数据做XOR操作。mask的生成需要一下信息：hashAlg（启动会话时传递的authHash参数），HMAC密钥，字符串“XOR”，nonceNewer，nonceOlder，以及KDFa的输出消息大小。输出的结果与将要被加密或者解密的数据长度相同。一个mask与数据的简单XOR操作就完成了XOR模式的加解密操作。

对于CFB模式来说，KDFa用于生成加密密钥和初始向量（Initialization Vector）。此时KDFa的输入参数包括hashAlg，sessionKey，字符串“CFB”，nonceNewer，nonceOlder，以及对称密钥和IV所需的位数（bits）。输出是bits长度的字符串，其中密钥位于较高的位置，IV则处于低位。IV的大小由加密算法的数据块大小决定。密钥和IV会作为加密算法的输入参数用于加解密操作。

对于XOR和CFB这两种模式来说，nonceNewer和nonceOlder都会用到加密中。对于XOR模式因为nonce会变化，所以命令响应和命令使用不同的mask值。类似的情况是，在CFB模式中，命令和命令响应使用的密钥和IV也不同。对于这两种模式来说，因为每次使用会话nonce都会变，所以加密解密会话被用作是一次性垫子。

### 伪码流
你可能会回忆起第13章的内容，会话可以使以下三种类型的一种：HMAC，Policy，或者Trial Policy会话。HMAC和Policy会话可以用作加密解密会话；Trial Policy则不能。

为了简单起见，以下的示例使用一个不用于授权的unbound，unsalted的Policy会话。这个会话仅仅用于加密和解密命令及命令响应参数。示例代码使用一个独立的会话用于授权。这就意味着这个测试代码的加密解密会话不需要计算HMAC或者管理policyDigest。

启动一个会话后，TPM会生成一个会话密钥。为了使用加密和解密会话，调用者需要独立产生这个会话密钥，就像他为了使用HMAC和Policy会话而不得不做的一些额外工作一样。

为了将加密解密会话统一成一个流程，它们涉及的相关步骤如下：
1. 使用TPM2_StartAuthSession，并设置对称加密算法相关的参数如下：
  1. CFB模式：

// AES encryption/decryption and CFB mode.
symmetric.algorithm = TPM_ALG_AES;
symmetric.keyBits.aes = 128;
symmetric.mode.aes = TPM_ALG_CFB;

  2. XOR模式：

// XOR encryption/decryption.
symmetric.algorithm = TPM_ALG_XOR;
symmetric.keyBits.exclusiveOr = TPM_ALG_SHA256;

2. 生成会话密钥，并保存它。
3. 对于第一个参数是TPM2B数据类型的命令，如果你希望加密这个参数，按以下步骤操作：
  1. 生成HMAC密钥。这个过程会使用会话密钥。
  2. 对于CFB模式：
    1. 生成加密密钥和IV，这会使用会话的哈希算法，HMAC密钥，特殊标志（“CFB”），nonceNewer，nonceOlder，需要加密数据的比特长度。
    2. 使用刚刚生成的加密密钥和IV加密第一个参数。
  3. 对于XOR模式：
    1. 生成mask值，需要用到HMAC密钥，会话的哈希算法，nonceNewer，nonceOlder，以及需要加密的字节长度。
    2. 使用mask值与明文做XOR操作从而生成密文。
  4. 设置sessionAttributes.decrypt。
4. 如果命令响应的第一个参数也是TPM2B类型的数据，并且你希望TPM加密它，那就设置sessionAttributes.encrypt。
5. 向TPM发送命令。
6. 从TPM接收命令响应。
7. 如果命令响应的第一个参数是TPM2B类型的数据，并且sessionAttributes.encrypt被置位，按以下步骤操作。
  1. 生成会话用的HMAC密钥。这个密钥的生成会使用会话密钥。
  2. 对于CFB模式：
    1. 生成加密密钥和IV，这会使用会话的哈希算法，HMAC密钥，特殊标志（“CFB”），nonceNewer，nonceOlder，需要解密数据的比特长度。
    2. 使用刚刚生成的加密密钥和IV解密第一个参数。
  3. 对于XOR模式：
    1. 生成mask值，需要用到HMAC密钥，会话的哈希算法，nonceNewer，nonceOlder，以及需要解密的字节长度。
    2. 使用mask值与密文做XOR操作从机密出第一个命令响应参数。

```
关于CFB以及XOR加密解密的详细信息，请参考TPM2.0规范第1部分中“Session-based encryption”这一节。
```

### 示例代码
## 总结
